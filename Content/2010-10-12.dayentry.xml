<?xml version="1.0" encoding="utf-8"?>
<DayEntry xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:newtelligence-com:dasblog:runtime:data">
  <Date>2010-10-11T20:00:00-04:00</Date>
  <Entries>
    <Entry>
      <Content>&lt;p&gt;This is a great title for a blog..here is a link of stuff I’d like to explore more:&lt;/p&gt;  &lt;p&gt;&lt;a href="http://blogs.msdn.com/b/ericlippert/archive/2010/07/12/graph-colouring-with-simple-backtracking-part-one.aspx"&gt;http://blogs.msdn.com/b/ericlippert/archive/2010/07/12/graph-colouring-with-simple-backtracking-part-one.aspx&lt;/a&gt;&lt;/p&gt;</Content>
      <Created>2010-10-12T18:58:41.0466283-04:00</Created>
      <Modified>2010-10-12T18:58:41.0466283-04:00</Modified>
      <EntryId>033d8856-f1cc-4090-94b8-6d7833f2ca31</EntryId>
      <Description />
      <Title>Fabulous Adventures in Coding</Title>
      <Categories>Blogs I Read</Categories>
      <Author>admin</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
    <Entry>
      <Content>&lt;p&gt;A Sudoku solver..Fun stuff.. &lt;/p&gt;  &lt;h3&gt;MatLab (Chris)&lt;/h3&gt;  &lt;p&gt;This doesn’t solve harder puzzles&lt;/p&gt;  &lt;div id="codeSnippetWrapper"&gt;   &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;function&lt;/span&gt; X = sudoku(X)&lt;br /&gt;&lt;br /&gt;[rows,cols] = size(X);&lt;br /&gt;&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; rows~=9 | cols~=9&lt;br /&gt; error(&lt;span style="color: #006080"&gt;'Invalid dimensions'&lt;/span&gt;)&lt;br /&gt;end&lt;br /&gt;nmax = max(rows,cols);&lt;br /&gt;siz = [rows,cols];&lt;br /&gt;elements = rows*cols;&lt;br /&gt;assn = find(X~=0);&lt;br /&gt;unassn = find(X==0);&lt;br /&gt;&lt;br /&gt;box = [1 2 3,[1 2 3]+rows,[1 2 3]+2*rows];&lt;br /&gt;bnum = rows/3*cols/3;&lt;br /&gt;bind = zeros(bnum,9);&lt;br /&gt;&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; b = 1:bnum&lt;br /&gt; bx = ceil(b/(cols/3));&lt;br /&gt; by = b - (bx-1)*(cols/3);&lt;br /&gt; bind(b,:) = box+(by-1)*3+(bx-1)*3*rows;&lt;br /&gt;end&lt;br /&gt;rind = zeros(rows,nmax);&lt;br /&gt;&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; r = 1:rows&lt;br /&gt; rind(r,:) = [1:rows:elements-rows+1] + r-1;&lt;br /&gt;end&lt;br /&gt;cind = zeros(cols,nmax);&lt;br /&gt;&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; c = 1:cols&lt;br /&gt; cind(c,:) = [1:rows] + (c-1)*rows;&lt;br /&gt;end&lt;br /&gt;&lt;br /&gt;%Initialise Y&lt;br /&gt;Y = repmat([1:nmax],[elements,1]);&lt;br /&gt;&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i = assn&lt;span style="color: #006080"&gt;'&lt;br /&gt; Y(i,:) = 0;&lt;br /&gt; Y(i,X(i)) = X(i);&lt;br /&gt;end&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;%Calculate Y&lt;br /&gt;while ~isempty(unassn)&lt;br /&gt;&lt;br /&gt; for ind = unassn'&lt;/span&gt;&lt;br /&gt;     [i,j] = ind2sub(siz,ind);&lt;br /&gt;     %Check row&lt;br /&gt;     rowassn = find(X(rind(i,:))~=0);&lt;br /&gt;     Y(ind,X(rind(i,rowassn))) = 0;&lt;br /&gt;     %Check col&lt;br /&gt;     colassn = find(X(cind(j,:))~=0);&lt;br /&gt;     Y(ind,X(cind(j,colassn))) = 0;&lt;br /&gt;     %Check box&lt;br /&gt;     by = ceil(i/3);&lt;br /&gt;     bx = ceil(j/3);&lt;br /&gt;     b = by + 3*(bx-1);&lt;br /&gt;     boxassn = find(X(bind(b,:))~=0);&lt;br /&gt;     Y(ind,X(bind(b,boxassn))) = 0;&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; sum(Y(ind,:)~=0)==1&lt;br /&gt;         X(ind) = Y(ind,find(Y(ind,:)~=0));&lt;br /&gt;     end&lt;br /&gt; end&lt;br /&gt;&lt;br /&gt; %Check row&lt;br /&gt; &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i = 1:rows&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; n = 1:nmax&lt;br /&gt;         nind = find(Y(rind(i,:),n)==n);&lt;br /&gt;         &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; length(nind)==1&lt;br /&gt;             Y(rind(i,nind),:) = 0;&lt;br /&gt;             Y(rind(i,nind),n) = n;&lt;br /&gt;             X(rind(i,nind)) = n;&lt;br /&gt;         end&lt;br /&gt;     end&lt;br /&gt; end&lt;br /&gt;&lt;br /&gt; %Check col&lt;br /&gt; &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i = 1:cols&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; n = 1:nmax&lt;br /&gt;         nind = find(Y(cind(i,:),n)==n);&lt;br /&gt;         &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; length(nind)==1&lt;br /&gt;             Y(cind(i,nind),:) = 0;&lt;br /&gt;             Y(cind(i,nind),n) = n;&lt;br /&gt;             X(cind(i,nind)) = n;&lt;br /&gt;         end&lt;br /&gt;     end&lt;br /&gt; end&lt;br /&gt;&lt;br /&gt; %Check box&lt;br /&gt; &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; i = 1:bnum&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; n = 1:nmax&lt;br /&gt;         nind = find(Y(bind(i,:),n)==n);&lt;br /&gt;         &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; length(nind)==1&lt;br /&gt;             Y(bind(i,nind),:) = 0;&lt;br /&gt;             Y(bind(i,nind),n) = n;&lt;br /&gt;             X(bind(i,nind)) = n;&lt;br /&gt;         end&lt;br /&gt;     end&lt;br /&gt; end&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; unassn = find(X==0);&lt;br /&gt; length(unassn)&lt;br /&gt; pause&lt;br /&gt;&lt;br /&gt;end&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;&amp;#160;&lt;/p&gt;

&lt;h3&gt;C++ (Michael)&lt;/h3&gt;

&lt;p&gt;So here is a c++ version that is intended to handle sudokus of various sizes(4x4,9x9,16x16...)
  &lt;br /&gt;It was intended to be a short program, but it was a little trickier and longer than I thought. However it seems to be working for a couple of test puzzles.&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;tchar.h&amp;gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;math.h&amp;gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;set&amp;gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;map&amp;gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;algorithm&amp;gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;vector&amp;gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;queue&amp;gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;iostream&amp;gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;ostream&amp;gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;boost/smart_ptr.hpp&amp;gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;//forward declarations&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; Cell;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;struct&lt;/span&gt; RowColumnBox;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; VectorMap;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; Grid;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; SolutionPoint;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// Convenient typedefs&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; std::set&amp;lt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;&amp;gt; OptionsSet;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; std::map&amp;lt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;, Cell&amp;gt; GridMap;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; std::vector&amp;lt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;&amp;gt; GroupVector;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; std::map&amp;lt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;, GroupVector&amp;gt; GroupVectorCollection;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; std::map&amp;lt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;, RowColumnBox&amp;gt; CellLocationMap;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; std::pair&amp;lt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;,&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;&amp;gt; CellValuePair;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; std::queue&amp;lt;CellValuePair&amp;gt; SolvedQueue;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; boost::shared_ptr&amp;lt;VectorMap&amp;gt; VectorMapPtr;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; boost::shared_ptr&amp;lt;SolutionPoint&amp;gt; SolutionPointPtr;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; boost::shared_ptr&amp;lt;Grid&amp;gt; GridPtr;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// helper functions for determining important dimensions of the grid&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;inline&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; CellCount( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size ) {      &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;&amp;gt;(pow( (&lt;span style="color: #0000ff"&gt;double&lt;/span&gt;)size, 4)); }&lt;br /&gt;&lt;span style="color: #0000ff"&gt;inline&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GridLength( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size ) { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; size * size;}&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// Just generates a sequence of numbers for filling in sequences into vectors etc&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; SequenceGenerator {&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; increment, current;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;       SequenceGenerator(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; inc, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; start) : increment(inc), current(start - inc) {;}&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;()() {&lt;br /&gt;               current += increment;&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; current;&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// Class holds all the available options for a cell&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; Options {&lt;br /&gt;       OptionsSet options;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;       Options(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size) {&lt;br /&gt;               std::generate_n( std::inserter(options, options.begin()), GridLength(size), SequenceGenerator(1, 1) );&lt;br /&gt;       }&lt;br /&gt;       Options(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Options&amp;amp; obj) : options(obj.options){&lt;br /&gt;       }&lt;br /&gt;       Options&amp;amp; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;=(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Options&amp;amp; obj ) {&lt;br /&gt;               options = obj.options;&lt;br /&gt;               &lt;span style="color: #008000"&gt;//std::copy( obj.options.begin(), obj.options.end(), std::inserter( options, options.begin() ) );&lt;/span&gt;&lt;br /&gt;       }&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns the value if there is only one possibility left else 0&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; RemoveOption( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; removeOption ) {&lt;br /&gt;               options.erase( removeOption );&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; (options.size() == 1) ? *options.begin() : 0;&lt;br /&gt;       }&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns a count of the available options for a cell&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetCount() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;&amp;gt;(options.size()); }&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetGuessValue( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; guessNumber ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               OptionsSet::const_iterator it = options.begin();&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; i = 0; i &amp;lt; guessNumber; ++i, ++it );&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; *it;&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// One cell from the grid&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; Cell {&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; value;&lt;br /&gt;       Options options;&lt;br /&gt;       Cell&amp;amp; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;=(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Cell&amp;amp;); &lt;span style="color: #008000"&gt;// at the moment don't need =&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;       Cell(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size) : options(size), value(0) {&lt;br /&gt;       }&lt;br /&gt;       Cell(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Cell&amp;amp; cell ) : value(cell.value), options(cell.options) {&lt;br /&gt;       }&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns true if removing an option has solved the cell else false&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; RemoveOption(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; option) {&lt;br /&gt;               &lt;span style="color: #008000"&gt;// if we have a value we no longer care about what we removing options&lt;/span&gt;&lt;br /&gt;               &lt;span style="color: #008000"&gt;// but if it is already solved don't return the value&lt;/span&gt;&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( !value ) {&lt;br /&gt;                       value = options.RemoveOption(option);&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; value;&lt;br /&gt;               }&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 0;&lt;br /&gt;       }&lt;br /&gt;       &lt;span style="color: #008000"&gt;// get/set for the value of the cell&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; SetValue( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; val ) { value = val; }&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetValue() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; value; }&lt;br /&gt;       &lt;span style="color: #008000"&gt;// checks if the cell is solved&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; IsSolved() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; (value != 0); }&lt;br /&gt;       &lt;span style="color: #008000"&gt;//returns a count of the availble options for a cell&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetOptionCount() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; value ? 0 : options.GetCount(); }&lt;br /&gt;       &lt;span style="color: #008000"&gt;// applies the guess number and returns the value guessed ( not equal to guessNumber )&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; ApplyGuess( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; guessNumber ) {&lt;br /&gt;               value = options.GetGuessValue( guessNumber );&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; value;&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// stores the row,column and box values for a cell&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// 0 based so -1 means not set.&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;struct&lt;/span&gt; RowColumnBox {&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; row;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; column;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; box;&lt;br /&gt;       RowColumnBox() : row(-1), column(-1), box(-1) {;}&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// returns an iterator pointing to the location of the given cell&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// if it cannot return a valid iterator an exception is thrown&lt;/span&gt;&lt;br /&gt;CellLocationMap::iterator GetCellMapLocation( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell, CellLocationMap&amp;amp; map ) {&lt;br /&gt;       CellLocationMap::iterator it = map.find( cell );&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( it == map.end() ) {&lt;br /&gt;               std::pair&amp;lt;CellLocationMap::iterator, &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt;&amp;gt; location&lt;br /&gt;                       = map.insert( std::make_pair( cell, RowColumnBox() ) );&lt;br /&gt;               _ASSERT( location.second );&lt;br /&gt;               it = location.first;&lt;br /&gt;       }&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; it;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// helper class for setting the row value&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;struct&lt;/span&gt; AddRowValueToCell{&lt;br /&gt;       AddRowValueToCell( CellLocationMap::iterator&amp;amp; it, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; row ) {&lt;br /&gt;               it-&amp;gt;second.row = row;&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;span style="color: #008000"&gt;// helper class for setting the column value&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;struct&lt;/span&gt; AddColumnValueToCell{&lt;br /&gt;       AddColumnValueToCell( CellLocationMap::iterator&amp;amp; it, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; column ) {&lt;br /&gt;               it-&amp;gt;second.column = column;&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;span style="color: #008000"&gt;// helper class for setting the box value&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;struct&lt;/span&gt; AddBoxValueToCell{&lt;br /&gt;       AddBoxValueToCell( CellLocationMap::iterator&amp;amp; it, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; box ) {&lt;br /&gt;               it-&amp;gt;second.box = box;&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// adds all the items in the groupvector to the appropriate cell location map&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// use one of the helper structs above for the template&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;template&lt;/span&gt; &amp;lt;&lt;span style="color: #0000ff"&gt;typename&lt;/span&gt; T&amp;gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; AddCellToCellMap {&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; item;&lt;br /&gt;       CellLocationMap&amp;amp; map;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;       AddCellToCellMap(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; i, CellLocationMap&amp;amp; m) : item(i), map(m) {;}&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;() ( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GroupVector::value_type&amp;amp; value ) {&lt;br /&gt;               CellLocationMap::iterator it = GetCellMapLocation( value, map );&lt;br /&gt;               T( it, item );&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// add a vector of cells(either row/column/box) to the cell location map&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// use one of the helper classes above for the template&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;template&lt;/span&gt; &amp;lt;&lt;span style="color: #0000ff"&gt;typename&lt;/span&gt; T&amp;gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; AddCellsToMap {&lt;br /&gt;       CellLocationMap&amp;amp; map;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;       AddCellsToMap( CellLocationMap&amp;amp; m ) : map(m) {;}&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;() ( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GroupVectorCollection::value_type&amp;amp; val ) {&lt;br /&gt;               std::for_each( val.second.begin(), val.second.end(), AddCellToCellMap&amp;lt;T&amp;gt;( val.first, map ) );&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// Contains maps for calculating row/column/box numbers from a given cell number&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// and vice-versa&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; VectorMap {&lt;br /&gt;       GroupVectorCollection rows;&lt;br /&gt;       GroupVectorCollection columns;&lt;br /&gt;       GroupVectorCollection boxes;&lt;br /&gt;       CellLocationMap cells;&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; RowInc(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;) { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;  1; }&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; ColumnInc( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size) { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; GridLength( size ); }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// used for filling in the sequences for the rows/columns maps&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; FillSequenceVector( GroupVectorCollection&amp;amp; col, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; item, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; inc, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; start, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; gridLength ) {&lt;br /&gt;               std::pair&amp;lt; GroupVectorCollection::iterator, &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt;&amp;gt;&lt;br /&gt;                       insertPair = col.insert( std::make_pair( item, GroupVector() ));&lt;br /&gt;&lt;br /&gt;               std::generate_n( std::back_inserter( insertPair.first-&amp;gt;second ),&lt;br /&gt;                       gridLength, SequenceGenerator( inc, start ) );&lt;br /&gt;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// initialises the rows/columns/boxes maps&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; InitCollectionMaps(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size) {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; gridLength = GridLength(size);&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; item = 0; item &amp;lt; gridLength; ++item ) {&lt;br /&gt;&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; boxRow = item / size; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; boxCol = item % size;&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; box = boxCol + boxRow * size;&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; boxStart = boxRow * GridLength(size) * size + boxCol * size;&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; rowStart = item * GridLength(size); &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; colStart = item;&lt;br /&gt;&lt;br /&gt;                       FillSequenceVector( rows, item, RowInc(size), rowStart, gridLength );&lt;br /&gt;                       FillSequenceVector( columns, item, ColumnInc(size), colStart, gridLength );&lt;br /&gt;&lt;br /&gt;                       &lt;span style="color: #008000"&gt;// the box is a little more tricky so can't just call FillVector&lt;/span&gt;&lt;br /&gt;                       std::pair&amp;lt; GroupVectorCollection::iterator, &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt;&amp;gt;&lt;br /&gt;                               insertPair = boxes.insert( std::make_pair( item, GroupVector() ));&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; ++i ) {&lt;br /&gt;                               std::generate_n( std::back_inserter(insertPair.first-&amp;gt;second), size,&lt;br /&gt;                                       SequenceGenerator(RowInc(size), i * GridLength(size) + boxStart) );&lt;br /&gt;&lt;br /&gt;                       }&lt;br /&gt;               }&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// loops through the rows/columns/boxes and fills in the cell location map&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; InitCellLocationMap(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size) {&lt;br /&gt;               std::for_each(rows.begin(), rows.end(), AddCellsToMap&amp;lt;AddRowValueToCell&amp;gt;(cells));&lt;br /&gt;               std::for_each(columns.begin(), columns.end(), AddCellsToMap&amp;lt;AddColumnValueToCell&amp;gt;(cells));&lt;br /&gt;               std::for_each(boxes.begin(), boxes.end(), AddCellsToMap&amp;lt;AddBoxValueToCell&amp;gt;(cells));&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       VectorMap(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; VectorMap&amp;amp;);&lt;br /&gt;       VectorMap&amp;amp; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;=(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; VectorMap&amp;amp;);&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;       VectorMap(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size)&lt;br /&gt;       {&lt;br /&gt;               InitCollectionMaps( size );&lt;br /&gt;               InitCellLocationMap(size );&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns the row number for a given cell number&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetRow( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               CellLocationMap::const_iterator it = cells.find(cell);&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; it == cells.end() ? -1 : it-&amp;gt;second.row;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns the column number for a given cell number&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetColumn( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               CellLocationMap::const_iterator it = cells.find(cell);&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; it == cells.end() ? -1 : it-&amp;gt;second.column;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns the box number for a given cell number&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetBox( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               CellLocationMap::const_iterator it = cells.find(cell);&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; it == cells.end() ? -1 : it-&amp;gt;second.box;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// need better error checking on these three accessors&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GroupVector&amp;amp; GetRowVector( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; row ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; rows.find( row )-&amp;gt;second;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GroupVector&amp;amp; GetColumnVector( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; column ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; columns.find( column )-&amp;gt;second;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GroupVector&amp;amp; GetBoxVector( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; box ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; boxes.find( box )-&amp;gt;second;&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// predicate for searching for cells with the right number of possibilities&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;struct&lt;/span&gt; CheckOptionCount&lt;br /&gt;       : &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; std::binary_function&amp;lt;GridMap::value_type, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;, &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt;&amp;gt; {&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;()(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GridMap::value_type&amp;amp; value, &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;&amp;amp; desiredOptionCount) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; (value.second.GetOptionCount() == desiredOptionCount);&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; Grid {&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; gridSize;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; solvedCount;&lt;br /&gt;       GridMap grid;&lt;br /&gt;       VectorMapPtr map;&lt;br /&gt;       SolvedQueue solved;&lt;br /&gt;&lt;br /&gt;       Grid&amp;amp; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;=(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Grid&amp;amp;);&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;       &lt;span style="color: #008000"&gt;// The initial grid is just 1d since we don't want to hard code in the 2d dimensions&lt;/span&gt;&lt;br /&gt;       Grid( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size, &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; initialGrid[] ) : gridSize(size), map( &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; VectorMap(size)),&lt;br /&gt;               solvedCount(CellCount(size)) {&lt;br /&gt;                       &lt;span style="color: #008000"&gt;// generate a blank grid&lt;/span&gt;&lt;br /&gt;                       std::generate_n( std::inserter( grid, grid.begin()), CellCount(size), CellInit(grid, gridSize));&lt;br /&gt;                       &lt;span style="color: #008000"&gt;//set the initial variables&lt;/span&gt;&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; gridLength = GridLength(size);&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; row = 0; row &amp;lt; gridLength; ++ row ) {&lt;br /&gt;                               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; col = 0; col &amp;lt; gridLength; ++ col){&lt;br /&gt;                                       &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell = row * gridLength + col;&lt;br /&gt;                                       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( initialGrid[cell] ) { &lt;span style="color: #008000"&gt;// most cells are 0 at the start(ie. blank)&lt;/span&gt;&lt;br /&gt;                                               SetCellValue( cell, initialGrid[cell] );&lt;br /&gt;                                       }&lt;br /&gt;                               }&lt;br /&gt;                       }&lt;br /&gt;                       SetSolvedQSolved();&lt;span style="color: #008000"&gt;//start off solution&lt;/span&gt;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       Grid( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Grid&amp;amp; obj ) :  &lt;span style="color: #008000"&gt;//copy constructor&lt;/span&gt;&lt;br /&gt;               gridSize(obj.gridSize),&lt;br /&gt;               map(obj.map),&lt;br /&gt;               solvedCount(obj.solvedCount),&lt;br /&gt;               solved(obj.solved),&lt;br /&gt;               grid(obj.grid){&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns true if the grid is solved&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; IsGridSolved() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; solvedCount == 0; }&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetCellsToSolveCount() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; solvedCount; }&lt;br /&gt;&lt;br /&gt;       VectorMapPtr GetMapPtr() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; map; }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns true if there are items in the solved queue that need to be dealt to&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; IsSolvedQEmpty() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; solved.empty(); }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// If we need to guess then returns the square with the least possible options&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// i.e. searches first for cells that have only 2 possible values and then&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// for cells with 3. (we want to find the cell with the best possible chance&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// of picking the right cell&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetBestGuessSquare() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( IsGridSolved() ) {&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; -1;&lt;br /&gt;               }&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; result = -1;&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; maxCount = GridLength( gridSize ) + 1;&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; desiredCount = 2; desiredCount &amp;lt; maxCount; ++ desiredCount ) {&lt;br /&gt;                       GridMap::const_iterator it = std::find_if( grid.begin(), grid.end(), std::bind2nd( CheckOptionCount(), desiredCount ));&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( it != grid.end() ) {&lt;br /&gt;                               result = it-&amp;gt;first;&lt;br /&gt;                               &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;&lt;br /&gt;                       }&lt;br /&gt;               }&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; result;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; Guess(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; guessNumber ) {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; value = grid.find(cell)-&amp;gt;second.ApplyGuess( guessNumber );&lt;br /&gt;               _ASSERT( value );&lt;br /&gt;               AddCellToSolvedQueue( cell, value );&lt;br /&gt;               SetSolvedQSolved();&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;//check to see if the grid is in an invalid state ( useful after applying guesses )&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; IsGridValid() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               GridMap::const_iterator it = std::find_if( grid.begin(), grid.end(), CheckGridValid(*&lt;span style="color: #0000ff"&gt;this&lt;/span&gt;));&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; it == grid.end();&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns the current value of a given cell&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetCellValue(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; grid.find(cell)-&amp;gt;second.GetValue();&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns a count of the available options&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; GetOptionCount(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; grid.find(cell)-&amp;gt;second.GetOptionCount();&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// draws a grid to the ostream source -- the _T macro reduces readibility&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; DisplayGrid( std::ostream&amp;amp; os ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt;{&lt;br /&gt;               os &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;\r\n&amp;quot;&lt;/span&gt;;&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; gridLength = GridLength( gridSize );&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; row = 0; row &amp;lt; gridLength; ++row ) {&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; col = 0; col &amp;lt; gridLength; ++ col ) {&lt;br /&gt;                               &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell = col + row * gridLength;&lt;br /&gt;                               os &amp;lt;&amp;lt; grid.find(cell)-&amp;gt;second.GetValue() &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot; &amp;quot;&lt;/span&gt;;&lt;br /&gt;                       }&lt;br /&gt;                       os &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;\r\n&amp;quot;&lt;/span&gt;; &lt;span style="color: #008000"&gt;// new line&lt;/span&gt;&lt;br /&gt;               }&lt;br /&gt;               os &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;\r\n&amp;quot;&lt;/span&gt;;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt;:&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// helper class for initialising the blank grid&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; CellInit {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; current;&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size;&lt;br /&gt;               GridMap&amp;amp; map;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;               CellInit(GridMap&amp;amp; m, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; gridSize) : current(0), map(m),size(gridSize) {;}&lt;br /&gt;               GridMap::value_type &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;()() {&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; std::make_pair( current++, Cell(size));&lt;br /&gt;               }&lt;br /&gt;       };&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// helper class for removing a value from a cell&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; RemoveCellValue {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; value;&lt;br /&gt;               Grid* grid;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;               RemoveCellValue( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; v , Grid* g ) :value(v), grid(g) {;}&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;()( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GroupVector::value_type&amp;amp; cell ) {&lt;br /&gt;                       &lt;span style="color: #008000"&gt;// if there is notification of a forced select then add it to the&lt;/span&gt;&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; solvedValue = grid-&amp;gt;RemoveValue( cell, value );&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( solvedValue ) {&lt;br /&gt;                               grid-&amp;gt;AddCellToSolvedQueue( cell, solvedValue );&lt;br /&gt;                       }&lt;br /&gt;               }&lt;br /&gt;       };&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// searches to find if the grid is invalid - ie. true if invalid ( false if valid )&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; CheckGridValid : &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; std::binary_function&amp;lt;GridMap::value_type, Grid, &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt;&amp;gt;&lt;br /&gt;       {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Grid&amp;amp; grid;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;               CheckGridValid(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Grid&amp;amp; g) : grid(g) {;}&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;()( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GridMap::value_type&amp;amp; value  ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; VectorMapPtr ptr = grid.GetMapPtr();&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(CheckVector( ptr-&amp;gt;GetColumnVector( ptr-&amp;gt;GetColumn( value.first )), value, grid ))&lt;br /&gt;                               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; true;&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(CheckVector( ptr-&amp;gt;GetRowVector( ptr-&amp;gt;GetRow( value.first )), value, grid ))&lt;br /&gt;                               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; true;&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;(CheckVector( ptr-&amp;gt;GetBoxVector( ptr-&amp;gt;GetBox( value.first )), value, grid ))&lt;br /&gt;                               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; true;&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; false;&lt;br /&gt;               }&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;private&lt;/span&gt;:&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; CheckVector( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GroupVector&amp;amp; vec, &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GridMap::value_type&amp;amp; value, &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Grid&amp;amp; grid ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt;{&lt;br /&gt;                       GroupVector::const_iterator it = std::find_if( vec.begin(), vec.end(), std::bind2nd( CheckCellValueExists(grid), value ) );&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; it != vec.end();&lt;br /&gt;               }&lt;br /&gt;       };&lt;br /&gt;       &lt;span style="color: #008000"&gt;// check that a cell matches the&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; CheckCellValueExists : &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; std::binary_function&amp;lt;GroupVector::value_type, GridMap::value_type, &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt;&amp;gt;&lt;br /&gt;       {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Grid&amp;amp; grid;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;               CheckCellValueExists( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Grid&amp;amp; g ) : grid(g) {;}&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;()( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GroupVector::value_type&amp;amp; value, &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GridMap::value_type&amp;amp; testValue ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; result = false;&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( testValue.second.GetValue() &amp;amp;&amp;amp; value != testValue.first ) { &lt;span style="color: #008000"&gt;//don't want to be comparing itself or checking zeros&lt;/span&gt;&lt;br /&gt;                               result = ( grid.GetCellValue( value ) == testValue.second.GetValue() );&lt;br /&gt;                       }&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; result;&lt;br /&gt;               }&lt;br /&gt;       };&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// sets a solved value&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; SetCellValue( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; value ) {&lt;br /&gt;               grid.find(cell)-&amp;gt;second.SetValue( value );&lt;br /&gt;               RemoveSolvedValue( cell, value );&lt;br /&gt;               --solvedCount;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// removes a solved value from the other rows/columns/boxes&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; RemoveSolvedValue( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; value ) {&lt;br /&gt;               RemoveRowCellValue( map-&amp;gt;GetRow( cell ), value );&lt;br /&gt;               RemoveColumnCellValue( map-&amp;gt;GetColumn( cell ), value );&lt;br /&gt;               RemoveBoxCellValue( map-&amp;gt;GetBox( cell ), value );&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// removes a value from all the squares in a row&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; RemoveRowCellValue( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; row, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; value ) {&lt;br /&gt;               std::for_each(map-&amp;gt;GetRowVector(row).begin(), map-&amp;gt;GetRowVector(row).end(), RemoveCellValue(value, &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;));&lt;br /&gt;       }&lt;br /&gt;       &lt;span style="color: #008000"&gt;// removes a value from all the squares in a column&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; RemoveColumnCellValue( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; column, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; value ) {&lt;br /&gt;               std::for_each(map-&amp;gt;GetColumnVector(column).begin(), map-&amp;gt;GetColumnVector(column).end(), RemoveCellValue(value, &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;));&lt;br /&gt;       }&lt;br /&gt;       &lt;span style="color: #008000"&gt;// removes a value from all the squares in a box&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; RemoveBoxCellValue( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; box, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; value ) {&lt;br /&gt;               std::for_each(map-&amp;gt;GetBoxVector(box).begin(), map-&amp;gt;GetBoxVector(box).end(), RemoveCellValue(value, &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;));&lt;br /&gt;       }&lt;br /&gt;       &lt;span style="color: #008000"&gt;// removes a value from a cell&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; RemoveValue( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; value ) {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; grid.find(cell)-&amp;gt;second.RemoveOption( value );&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// adds a cell to the solved queue&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; AddCellToSolvedQueue( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; value ) {&lt;br /&gt;               solved.push( std::make_pair( cell, value) );&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// loops throught the solved queue and removes the value from the rows/colums/boxes&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; SetSolvedQSolved() {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;while&lt;/span&gt;( !solved.empty() &amp;amp;&amp;amp; solvedCount ) {&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; CellValuePair pair = solved.front();&lt;br /&gt;                       solved.pop();&lt;br /&gt;                       RemoveSolvedValue( pair.first, pair.second );&lt;br /&gt;                       --solvedCount;&lt;br /&gt;               }&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// Stores a copy of the grid and the status of the guesses at a given point&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; SolutionPoint {&lt;br /&gt;       GridPtr grid; &lt;span style="color: #008000"&gt;// the grid before the guess&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; guessCell; &lt;span style="color: #008000"&gt;// the cell we are guessing&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; guessNumber; &lt;span style="color: #008000"&gt;// the guess number that we are going to try next(NOT THE VALUE OF THE GUESS )&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; guessCount; &lt;span style="color: #008000"&gt;// the number of possible guesses for that cell&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;       SolutionPoint( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; Grid&amp;amp; g, &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; cell ) : grid( &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Grid(g) ),&lt;br /&gt;               guessNumber(0), guessCell(cell) {&lt;br /&gt;               guessCount = g.GetOptionCount(cell);&lt;br /&gt;       }&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; TriedAllGuesses() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; guessNumber == guessCount; }&lt;br /&gt;       &lt;span style="color: #008000"&gt;// applies the next guess to a copy of the stored grid&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// returns a pointer the the grid once it is solved&lt;/span&gt;&lt;br /&gt;       GridPtr ApplyNextGuess() {&lt;br /&gt;               _ASSERT( !TriedAllGuesses() );&lt;br /&gt;               GridPtr ptr = GridPtr( &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Grid( *grid ) );&lt;br /&gt;               ptr-&amp;gt;Guess( guessCell, guessNumber++ );&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; ptr;&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// Class that performs the solving of the grid&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; GridSolver {&lt;br /&gt;       GridPtr mainGrid; &lt;span style="color: #008000"&gt;// the grid on which all the working is performed&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; solved; &lt;span style="color: #008000"&gt;// is the current mainGrid solved&lt;/span&gt;&lt;br /&gt;       GridSolver(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GridSolver&amp;amp;);&lt;br /&gt;       GridSolver&amp;amp; &lt;span style="color: #0000ff"&gt;operator&lt;/span&gt;=(&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; GridSolver&amp;amp;);&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt;:&lt;br /&gt;       GridSolver( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; size, &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; initialGrid[] ) :&lt;br /&gt;               mainGrid( &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Grid( size, initialGrid)) {&lt;br /&gt;                       solved = mainGrid-&amp;gt;IsGridSolved();&lt;br /&gt;                       _ASSERT( mainGrid-&amp;gt;IsGridValid()); &lt;span style="color: #008000"&gt;// this will pick up bad initial grids ( at least in debug )&lt;/span&gt;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// call this to solve the grid&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; Solve()  {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( !solved )&lt;br /&gt;                       RecursiveGuessLoop( CreateGuessPoint() );&lt;br /&gt;               _ASSERT( !solved || mainGrid-&amp;gt;IsGridValid() );&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; solved;&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; DisplayGrid( std::ostream&amp;amp; os ) &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; {&lt;br /&gt;               mainGrid-&amp;gt;DisplayGrid( os );&lt;br /&gt;       }&lt;br /&gt;&lt;span style="color: #0000ff"&gt;private&lt;/span&gt;:&lt;br /&gt;       &lt;span style="color: #008000"&gt;// recursive function for applying guesses until we find a solution&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// ( or run out of guesses )&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; RecursiveGuessLoop( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; SolutionPointPtr&amp;amp; ptr ) {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;while&lt;/span&gt;(!solved &amp;amp;&amp;amp; !ptr-&amp;gt;TriedAllGuesses() ) {&lt;br /&gt;                       mainGrid = ptr-&amp;gt;ApplyNextGuess();&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( !mainGrid-&amp;gt;IsGridSolved() ) {&lt;br /&gt;                               RecursiveGuessLoop( CreateGuessPoint() ); &lt;span style="color: #008000"&gt;// recursion&lt;/span&gt;&lt;br /&gt;                       } &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( mainGrid-&amp;gt;IsGridValid() ) {&lt;br /&gt;                               solved = true;&lt;br /&gt;                               &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;&lt;br /&gt;                       }&lt;br /&gt;               }&lt;br /&gt;       }&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #008000"&gt;// just a convient function to help me type a long line -&amp;gt; I'm too lazy&lt;/span&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;inline&lt;/span&gt; SolutionPointPtr CreateGuessPoint() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt;{&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; SolutionPointPtr( &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; SolutionPoint( *mainGrid, mainGrid-&amp;gt;GetBestGuessSquare() ));&lt;br /&gt;       }&lt;br /&gt;};&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; puzzle2[] = {&lt;br /&gt;1,0,0,2,&lt;br /&gt;0,2,0,0,&lt;br /&gt;0,0,4,0,&lt;br /&gt;0,3,0,0 };&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; puzzleTest[] = {&lt;br /&gt;0,6,0,1,0,4,0,5,0,&lt;br /&gt;0,0,8,3,0,5,6,0,0,&lt;br /&gt;2,0,0,0,0,0,0,0,1,&lt;br /&gt;8,0,0,4,0,7,0,0,6,&lt;br /&gt;0,0,6,0,0,0,3,0,0,&lt;br /&gt;7,0,0,9,0,1,0,0,4,&lt;br /&gt;5,0,0,0,0,0,0,0,2,&lt;br /&gt;0,0,7,2,0,6,9,0,0,&lt;br /&gt;0,4,0,5,0,8,0,7,0 };&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; puzzlePress1[] = {&lt;br /&gt;7,0,0,4,0,0,3,0,0,&lt;br /&gt;0,0,0,0,0,1,7,0,0,&lt;br /&gt;0,2,0,0,0,0,9,0,1,&lt;br /&gt;0,0,1,0,4,0,2,0,0,&lt;br /&gt;0,6,0,8,9,7,0,3,0,&lt;br /&gt;0,0,8,0,2,0,5,0,0,&lt;br /&gt;3,0,9,0,0,0,0,1,0,&lt;br /&gt;0,0,7,9,0,0,0,0,0,&lt;br /&gt;0,0,2,0,0,5,0,0,3 };&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; puzzleHard1[] = {&lt;br /&gt;6,0,0,0,0,0,0,4,0,&lt;br /&gt;0,0,5,0,0,2,0,0,7,&lt;br /&gt;7,2,9,0,0,0,0,0,3,&lt;br /&gt;0,9,0,0,4,0,0,0,1,&lt;br /&gt;0,0,0,0,6,0,0,0,0,&lt;br /&gt;4,0,0,0,8,0,0,7,0,&lt;br /&gt;3,0,0,0,0,0,1,6,5,&lt;br /&gt;2,0,0,4,0,0,8,0,0,&lt;br /&gt;0,5,0,0,0,0,0,0,4 };&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; puzzleHard2[] = {&lt;br /&gt;0,0,9,0,8,0,0,0,4,&lt;br /&gt;0,6,0,0,0,0,0,0,8,&lt;br /&gt;5,2,8,0,6,0,1,7,0,&lt;br /&gt;2,0,0,7,0,0,0,0,5,&lt;br /&gt;0,0,0,4,0,6,0,0,0,&lt;br /&gt;9,0,0,0,0,1,0,0,6,&lt;br /&gt;0,9,7,0,3,0,4,6,1,&lt;br /&gt;6,0,0,0,0,0,0,3,0,&lt;br /&gt;3,0,0,0,4,0,9,0,0 };&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; _tmain(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; argc, _TCHAR* argv[])&lt;br /&gt;{&lt;br /&gt;       GridSolver solver(3, puzzleTest);&lt;br /&gt;       std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;Solved = &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; solver.Solve() &amp;lt;&amp;lt; std::endl;&lt;br /&gt;       solver.DisplayGrid(std::cout);&lt;br /&gt;&lt;br /&gt;       GridSolver solver2(2, puzzle2);&lt;br /&gt;       std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;Solved = &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; solver2.Solve() &amp;lt;&amp;lt; std::endl;&lt;br /&gt;       solver2.DisplayGrid(std::cout);&lt;br /&gt;&lt;br /&gt;       GridSolver solver3(3, puzzlePress1);&lt;br /&gt;       std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;Solved = &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; solver3.Solve() &amp;lt;&amp;lt; std::endl;&lt;br /&gt;       solver3.DisplayGrid(std::cout);&lt;br /&gt;&lt;br /&gt;       GridSolver solver4(3, puzzleHard2);&lt;br /&gt;       std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;Solved = &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; solver4.Solve() &amp;lt;&amp;lt; std::endl;&lt;br /&gt;       solver4.DisplayGrid(std::cout);&lt;br /&gt;&lt;br /&gt;       GridSolver solver5(3, puzzleHard1);&lt;br /&gt;       std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;Solved = &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; solver5.Solve() &amp;lt;&amp;lt; std::endl;&lt;br /&gt;       solver5.DisplayGrid(std::cout);&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 0;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;By some miracle it is looking pretty good - ( I managed to correct a bug in my recursive function which was causing some grief )
  &lt;br /&gt;Here is a brief explanation of what I think I did ( any resemblance to actual code is purely coincidental )

  &lt;br /&gt;Notes:

  &lt;br /&gt;1) There are quite a few classes just used as predicates for stl algorithms

  &lt;br /&gt;2) The grid dimensions are given as 2 for a 4x4, 3 for a 9x9, 4 for a 16x16 etc and the solver should be able to solve any of these...(the 2x2 test works well

  &lt;br /&gt;3) The main classes:

  &lt;br /&gt;&lt;b&gt;Options&lt;/b&gt; holds a list of the possible values for a cell basically just a vector that starts of with all the possible numbers (1...9) and erases them as they are no longer a possibilty&lt;b&gt;
    &lt;br /&gt;Cell&lt;/b&gt; A representation of a sudoku cell. Stores a value for the cell (0 if unassigned ) and a list of possible options for the cell.

  &lt;br /&gt;&lt;b&gt;Grid&lt;/b&gt; Contains a map of all the cells in the sudoku grid. Cells are number from 0 at the top left corner the the 1,2,3 moving along the row and finally 81 in the bottom right hand corner.

  &lt;br /&gt;&lt;b&gt;VectorMap&lt;/b&gt; Basically maps a cell number to a row number, column number, and box number. Also contains lists of all the cells each row/column/box.

  &lt;br /&gt;&lt;b&gt;SolutionPoint&lt;/b&gt; Keeps track of the current guess we are making.

  &lt;br /&gt;&lt;b&gt;GridSolver&lt;/b&gt; Implements the recursive solving mechanism.

  &lt;br /&gt;All the other class/struct are just helpers for the stl functions i.e. std::find_if, std::for_each, etc

  &lt;br /&gt;How it works:

  &lt;br /&gt;1) In the grid constructor:

  &lt;br /&gt;a) Creates a blank grid with each cell having all options available.

  &lt;br /&gt;b) Starts adding the given numbers. This involves setting the value in the cell and removing that value as an option from the other cells in the same row/column/box.

  &lt;br /&gt;note: as options are removed from a cell, that cell may reach the point where there is only one remaining value and hence is solved. In this case the cell is added to the solved queue.

  &lt;br /&gt;c) Iterates through the solved queue and removes value of the solved cell from the option list in the same row/column/box

  &lt;br /&gt;For easy/medium puzzles step c is usually self sustaining and when it is completed the puzzle is solved.

  &lt;br /&gt;If this is not the case then we need some more advanced logic, or for the lazy, guessing. I went with guessing.

  &lt;br /&gt;2) In the GridSolver.Solve Function

  &lt;br /&gt;- check that the grid was not solved as described above. Then guess

  &lt;br /&gt;a) find the first cell with the minimum of options ( so there is a good chance of guessing correctly ) ie. search for cells with 2 possibilties then 3..4..5 etc

  &lt;br /&gt;b) Choose the next guess ( storing a copy of the current grid /which guess etc )

  &lt;br /&gt;c) Iterates through the solved queue and removes value of the solved cell from the option list in the same row/column/box

  &lt;br /&gt;d) Check if there is a solution -&amp;gt; (no) goto step a&amp;#160; (yes)continue

  &lt;br /&gt;e) Check if the solution is valid -&amp;gt; (no) retreat to the last guess point and goto step b (yes) solved!!!!111!!!!one1!!!11eleven!!!!

  &lt;br /&gt;steps a-d are implemented as a recursive function.

  &lt;br /&gt;The solver should work&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.codeproject.com/csharp/sudoku.asp"&gt;www.codeproject.com/csharp/sudoku.asp&lt;/a&gt;&lt;/p&gt;</Content>
      <Created>2010-10-12T18:40:39.9377239-04:00</Created>
      <Modified>2010-10-12T18:54:42.3941387-04:00</Modified>
      <EntryId>cf17718a-8dd2-444b-a39e-42ff4b7c84f9</EntryId>
      <Description />
      <Title>Sudoku</Title>
      <Categories>Coding Challenge</Categories>
      <Author>admin</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
    <Entry>
      <Content>&lt;p&gt;This was an older blog post from 2006, and I found the text from ‘The Wayback Machine’ ie web.archive.org, on davemateer.com&lt;/p&gt;  &lt;p&gt;Whilst reading Simon Sing's - The Code Book (www.simonsingh.com)&amp;#160; I thought it would be fun to write a code guessing program.&amp;#160; My first try was in Visual Basic6, then I ported it over to C#.&amp;#160; Phil decided he'd have a go and wrote it in Python then Java.&amp;#160; Then Dan wrote it in C.&amp;#160; We were all intrigued as to how fast each language would be, and who would be the winner?&lt;/p&gt;  &lt;p&gt;   &lt;br /&gt;This program takes say x letters from lowercase a to z, in as a secretString (in all cases we used 'davedave' for 8, then 'davedav' for 7 etc..)&amp;#160; Then it tries to guess the secretString by starting at aaaaaaaa and finishing at zzzzzzzz (for the 8 length example).&amp;#160; It was not allowed guess each letter individually, it had to guess the entire string correctly.&lt;/p&gt;  &lt;p&gt;My machine ran an Athlon 1500+ processor with 0.75gig of RAM, and WinXPSP2.&lt;/p&gt;  &lt;p&gt;&lt;a href="http://www.programgood.net/content/binary/WindowsLiveWriter/CodeGuessingProgram_8FC5/image_2.png"&gt;&lt;img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="http://www.programgood.net/content/binary/WindowsLiveWriter/CodeGuessingProgram_8FC5/image_thumb.png" width="644" height="221" /&gt;&lt;/a&gt; &lt;/p&gt;  &lt;p&gt;So Cv1.1 and C#v3 got pretty close.&lt;/p&gt;  &lt;h3&gt;C# v2 (thanks to Kelly)&lt;/h3&gt;  &lt;div&gt;   &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;namespace&lt;/span&gt; pattern_string_version2 &lt;br /&gt;&lt;br /&gt;{ &lt;br /&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; Program&lt;br /&gt;&lt;br /&gt;    {&lt;br /&gt;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; Main(&lt;span style="color: #0000ff"&gt;string&lt;/span&gt;[] args)&lt;br /&gt;&lt;br /&gt;        {&lt;br /&gt;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; secretString = &lt;span style="color: #006080"&gt;&amp;quot;davedave&amp;quot;&lt;/span&gt;;&lt;br /&gt;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; counter = 0;&lt;br /&gt;&lt;br /&gt; &lt;br /&gt;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[] ts = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[8];&lt;br /&gt;&lt;br /&gt; &lt;br /&gt;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; timeStart;&lt;br /&gt;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; timeEnd;&lt;br /&gt;&lt;br /&gt;            timeStart = DateTime.Now.Hour.ToString() + &lt;span style="color: #006080"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + DateTime.Now.Minute.ToString() + &lt;span style="color: #006080"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + DateTime.Now.Second.ToString();&lt;br /&gt;&lt;br /&gt;            Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;time at start is {0}&amp;quot;&lt;/span&gt;, timeStart);&lt;br /&gt;&lt;br /&gt; &lt;br /&gt;&lt;br /&gt;            &lt;span style="color: #008000"&gt;//loop 1&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; i = 97; i &amp;lt; 123; i++)&lt;br /&gt;&lt;br /&gt;            {&lt;br /&gt;&lt;br /&gt;                &lt;span style="color: #008000"&gt;//loop2&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; j = 97; j &amp;lt; 123; j++)&lt;br /&gt;&lt;br /&gt;                {&lt;br /&gt;&lt;br /&gt;                    &lt;span style="color: #008000"&gt;//loop3&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; k = 97; k &amp;lt; 123; k++)&lt;br /&gt;&lt;br /&gt;                    {          &lt;br /&gt;&lt;br /&gt;                        &lt;span style="color: #008000"&gt;//loop4&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; l = 97; l &amp;lt; 123; l++)&lt;br /&gt;&lt;br /&gt;                        {&lt;br /&gt;&lt;br /&gt;                            &lt;span style="color: #008000"&gt;//loop5&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; m = 97; m &amp;lt; 123; m++)&lt;br /&gt;&lt;br /&gt;                            {&lt;br /&gt;&lt;br /&gt;                                &lt;span style="color: #008000"&gt;//loop6&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; n = 97; n &amp;lt; 123; n++)&lt;br /&gt;&lt;br /&gt;                                {&lt;br /&gt;&lt;br /&gt;                                    &lt;span style="color: #008000"&gt;//loop7&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; o = 97; o &amp;lt; 123; o++)&lt;br /&gt;&lt;br /&gt;                                    {&lt;br /&gt;&lt;br /&gt;                                        &lt;span style="color: #008000"&gt;//loop8&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; p = 97; p &amp;lt; 123; p++)&lt;br /&gt;&lt;br /&gt;                                        {&lt;br /&gt;&lt;br /&gt;                                            ts[0] = i;&lt;br /&gt;&lt;br /&gt;                                            ts[1] = j;&lt;br /&gt;&lt;br /&gt;                                            ts[2] = k;&lt;br /&gt;&lt;br /&gt;                                            ts[3] = l;&lt;br /&gt;&lt;br /&gt;                                            ts[4] = m;&lt;br /&gt;&lt;br /&gt;                                            ts[5] = n;&lt;br /&gt;&lt;br /&gt;                                            ts[6] = o;&lt;br /&gt;&lt;br /&gt;                                            ts[7] = p;&lt;br /&gt;&lt;br /&gt; &lt;br /&gt;&lt;br /&gt;                                            counter++;&lt;br /&gt;&lt;br /&gt; &lt;br /&gt;&lt;br /&gt;                                            &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; ts2 = System.Text.ASCIIEncoding.ASCII.GetString(ts, 0,8);&lt;br /&gt;&lt;br /&gt; &lt;br /&gt;&lt;br /&gt;                                            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (ts2.Equals(secretString))&lt;br /&gt;&lt;br /&gt;                                            {&lt;br /&gt;&lt;br /&gt;                                                Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;Found secret which is {0} after {1} pattern matches&amp;quot;&lt;/span&gt;, ts, counter);&lt;br /&gt;&lt;br /&gt;                                                Console.WriteLine();&lt;br /&gt;&lt;br /&gt;                                                timeEnd = DateTime.Now.Hour.ToString() + &lt;span style="color: #006080"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + DateTime.Now.Minute.ToString() + &lt;span style="color: #006080"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + DateTime.Now.Second.ToString();&lt;br /&gt;&lt;br /&gt;                                                Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;time at end is {0}&amp;quot;&lt;/span&gt;, timeEnd);&lt;br /&gt;&lt;br /&gt;                                                &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;&lt;br /&gt;&lt;br /&gt;                                            }&lt;span style="color: #008000"&gt;// End if                                                                                      &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                        } &lt;span style="color: #008000"&gt;//end loop 8&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                    } &lt;span style="color: #008000"&gt;// end loop 7&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                }&lt;span style="color: #008000"&gt;// end loop 6&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                            }&lt;span style="color: #008000"&gt;//end loop5&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                        }&lt;span style="color: #008000"&gt;//end loop4&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                    }&lt;span style="color: #008000"&gt;//end loop3&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                }&lt;span style="color: #008000"&gt;//end loop2&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;            }&lt;span style="color: #008000"&gt;//end loop1&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;         }&lt;span style="color: #008000"&gt;// End Main&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    }&lt;span style="color: #008000"&gt;// End Program&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;}// End Namespace &lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;h3&gt;C# V3 (thanks Dave Mulh, Phil, Darrin) – nested version&lt;/h3&gt;

&lt;p&gt;This may be the fastest C#?&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;using&lt;/span&gt; System;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;using&lt;/span&gt; System.Text;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;namespace&lt;/span&gt; pattern_string_version3&lt;br /&gt;{&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; PatternMatch&lt;br /&gt;    {&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; Main(&lt;span style="color: #0000ff"&gt;string&lt;/span&gt;[] args)&lt;br /&gt;        {&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[] SecretBytes = Encoding.UTF8.GetBytes(&lt;span style="color: #006080"&gt;&amp;quot;davedav&amp;quot;&lt;/span&gt;);&lt;br /&gt;            &lt;span style="color: #008000"&gt;//int counter = 0;&lt;/span&gt;&lt;br /&gt;            &lt;span style="color: #008000"&gt;// A 64 bit type giving a large number&lt;/span&gt;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;ulong&lt;/span&gt; counter = 0;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[] ComparisonBytes = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[7];&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; timeStart;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; timeEnd;&lt;br /&gt;&lt;br /&gt;            timeStart = DateTime.Now.Hour.ToString() + &lt;span style="color: #006080"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + DateTime.Now.Minute.ToString() + &lt;span style="color: #006080"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + DateTime.Now.Second.ToString();&lt;br /&gt;&lt;br /&gt;            &lt;span style="color: #008000"&gt;//loop 1&lt;/span&gt;&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; i = 97; i &amp;lt; 123; i++)&lt;br /&gt;            {&lt;br /&gt;                ComparisonBytes[0] = i;&lt;br /&gt;                &lt;span style="color: #008000"&gt;//loop2&lt;/span&gt;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; j = 97; j &amp;lt; 123; j++)&lt;br /&gt;                {&lt;br /&gt;                    ComparisonBytes[1] = j;                    &lt;br /&gt;                    &lt;span style="color: #008000"&gt;//loop 3&lt;/span&gt;&lt;br /&gt;                    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; k = 97; k &amp;lt; 123; k++)&lt;br /&gt;                    {&lt;br /&gt;                        ComparisonBytes[2] = k;                        &lt;br /&gt;                        &lt;span style="color: #008000"&gt;//loop4&lt;/span&gt;&lt;br /&gt;                        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; l = 97; l &amp;lt; 123; l++)&lt;br /&gt;                        {&lt;br /&gt;                            ComparisonBytes[3] = l;                            &lt;br /&gt;                            &lt;span style="color: #008000"&gt;//loop 5&lt;/span&gt;&lt;br /&gt;                            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; m = 97; m &amp;lt; 123; m++)&lt;br /&gt;                            {&lt;br /&gt;                                ComparisonBytes[4] = m;&lt;br /&gt;                                &lt;span style="color: #008000"&gt;//loop6&lt;/span&gt;&lt;br /&gt;                                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; n = 97; n &amp;lt; 123; n++)&lt;br /&gt;                                {&lt;br /&gt;                                    ComparisonBytes[5] = n;&lt;br /&gt;                                    &lt;span style="color: #008000"&gt;//loop7&lt;/span&gt;&lt;br /&gt;                                    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; o = 97; o &amp;lt; 123; o++)&lt;br /&gt;                                    {&lt;br /&gt;                                        ComparisonBytes[6] = o;&lt;br /&gt;                                        &lt;span style="color: #008000"&gt;//loop8&lt;/span&gt;&lt;br /&gt;                                        &lt;span style="color: #008000"&gt;//for (byte p = 97; p &amp;lt; 123; p++)&lt;/span&gt;&lt;br /&gt;                                        &lt;span style="color: #008000"&gt;//{&lt;/span&gt;&lt;br /&gt;                                           &lt;span style="color: #008000"&gt;// ComparisonBytes[7] = p;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                            counter++;&lt;br /&gt;&lt;br /&gt;                                            &lt;span style="color: #008000"&gt;//bool match = CompareByteArrays(ComparisonBytes,SecretBytes);&lt;/span&gt;&lt;br /&gt;                                            &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (CompareByteArrays(ComparisonBytes, SecretBytes))&lt;br /&gt;                                            {&lt;br /&gt;                                                timeEnd = DateTime.Now.Hour.ToString() + &lt;span style="color: #006080"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + DateTime.Now.Minute.ToString() + &lt;span style="color: #006080"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + DateTime.Now.Second.ToString();&lt;br /&gt;                                                &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; matchedString = System.Text.ASCIIEncoding.ASCII.GetString(ComparisonBytes, 0, 7);&lt;br /&gt;                                                Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;Found secret which is {0} after {1} pattern matches&amp;quot;&lt;/span&gt;, matchedString, &lt;span style="color: #006080"&gt;&amp;quot;counter&amp;quot;&lt;/span&gt;);&lt;br /&gt;                                                Console.WriteLine();&lt;br /&gt;                                                Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;time at start is {0}&amp;quot;&lt;/span&gt;, timeStart);&lt;br /&gt;                                                Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;time at end is {0}&amp;quot;&lt;/span&gt;, timeEnd);&lt;br /&gt;                                                Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;counter is {0}&amp;quot;&lt;/span&gt;, counter);&lt;br /&gt;                                                &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;&lt;br /&gt;                                            }&lt;span style="color: #008000"&gt;// End &lt;/span&gt;&lt;br /&gt;                                        &lt;span style="color: #008000"&gt;//} //end loop 8&lt;/span&gt;&lt;br /&gt;                                    }&lt;span style="color: #008000"&gt;//end loop 7&lt;/span&gt;&lt;br /&gt;                                } &lt;span style="color: #008000"&gt;// end loop 6&lt;/span&gt;&lt;br /&gt;                            }&lt;span style="color: #008000"&gt;// end loop 5&lt;/span&gt;&lt;br /&gt;                        } &lt;span style="color: #008000"&gt;//end loop 4&lt;/span&gt;&lt;br /&gt;                    } &lt;span style="color: #008000"&gt;// end loop 3&lt;/span&gt;&lt;br /&gt;                }&lt;span style="color: #008000"&gt;// end loop 2&lt;/span&gt;&lt;br /&gt;            }&lt;span style="color: #008000"&gt;//end 1&lt;/span&gt;&lt;br /&gt;            &lt;span style="color: #008000"&gt;//we failed, so output error&lt;/span&gt;&lt;br /&gt;            Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;Didn't Found secret which  after {0} pattern matches&amp;quot;&lt;/span&gt;, &lt;span style="color: #006080"&gt;&amp;quot;counter&amp;quot;&lt;/span&gt;);&lt;br /&gt;            Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;time at start is {0}&amp;quot;&lt;/span&gt;, timeStart);&lt;br /&gt;            Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;time at end is {0}&amp;quot;&lt;/span&gt;, DateTime.Now.Hour.ToString() + &lt;span style="color: #006080"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + DateTime.Now.Minute.ToString() + &lt;span style="color: #006080"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; + DateTime.Now.Second.ToString());&lt;br /&gt;            Console.ReadLine();&lt;br /&gt;        }&lt;span style="color: #008000"&gt;// End Main&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; CompareByteArrays(&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[] data1, &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[] data2)&lt;br /&gt;        {&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; i = 0; i &amp;lt; 7; i++)&lt;br /&gt;            {&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (data1[i] != data2[i])&lt;br /&gt;                {&lt;br /&gt;                    &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;false&lt;/span&gt;;&lt;br /&gt;                }&lt;br /&gt;            }&lt;br /&gt;            &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #0000ff"&gt;true&lt;/span&gt;;&lt;br /&gt;        }&lt;br /&gt;    }&lt;span style="color: #008000"&gt;// End Program&lt;/span&gt;&lt;br /&gt;}// End Namespace&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;div&gt;
  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;C# (Kelly’s Byte by Byte cheat!)&lt;/h3&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;using&lt;/span&gt; System;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;using&lt;/span&gt; System.Text;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;namespace&lt;/span&gt; Proto&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;/// Summary description for Class1.&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; Class1&lt;br /&gt;&lt;br /&gt;      {&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;/// The main entry point for the application.&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;            [STAThread]&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; Main( &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; [] args)&lt;br /&gt;&lt;br /&gt;            {&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; [] SecretBytes = Encoding.UTF8.GetBytes(&lt;span style="color: #006080"&gt;&amp;quot;davedave&amp;quot;&lt;/span&gt;);&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; [] ComparisonBytes = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt; [8] {97,97,97,97,97,97,97,97};&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; index = 0;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;string&lt;/span&gt; timeStart = String.Format(&lt;span style="color: #006080"&gt;&amp;quot;{0}:{1}:{2}&amp;quot;&lt;/span&gt;, DateTime.Now.Hour.ToString(), DateTime.Now.Minute.ToString(), DateTime.Now.Second.ToString());&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// Start Processing&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;while&lt;/span&gt; (SecretBytes.Length &amp;gt; index)&lt;br /&gt;&lt;br /&gt;                  {&lt;br /&gt;&lt;br /&gt;                        ComparisonBytes[index]++;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (ComparisonBytes[index].Equals (SecretBytes[index]))&lt;br /&gt;&lt;br /&gt;                              index++;&lt;br /&gt;&lt;br /&gt;                  }&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// End Processing&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;string&lt;/span&gt; timeEnd = String.Format(&lt;span style="color: #006080"&gt;&amp;quot;{0}:{1}:{2}&amp;quot;&lt;/span&gt;, DateTime.Now.Hour.ToString(), DateTime.Now.Minute.ToString(), DateTime.Now.Second.ToString ());&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;string&lt;/span&gt; matchedString=System.Text.ASCIIEncoding .ASCII.GetString(ComparisonBytes, 0,8);&lt;br /&gt;&lt;br /&gt;                  Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;Found secret which is {0} after {1} pattern matches&amp;quot;&lt;/span&gt;,matchedString, &lt;span style="color: #006080"&gt;&amp;quot;counter&amp;quot;&lt;/span&gt;);&lt;br /&gt;&lt;br /&gt;                  Console.WriteLine();&lt;br /&gt;&lt;br /&gt;                  Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;time at start is {0}&amp;quot;&lt;/span&gt;, timeStart);&lt;br /&gt;&lt;br /&gt;                  Console.WriteLine(&lt;span style="color: #006080"&gt;&amp;quot;time at end is {0}&amp;quot;&lt;/span&gt;, timeEnd);&lt;br /&gt;&lt;br /&gt;                  Console.ReadLine();&lt;br /&gt;&lt;br /&gt;            }&lt;br /&gt;&lt;br /&gt;      }&lt;br /&gt;&lt;br /&gt;}&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;PHP&lt;/h3&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;PHP Code&lt;br /&gt;&lt;br /&gt; Run from the command line eg php pattern.php&lt;br /&gt;&lt;br /&gt;&amp;lt;? &lt;br /&gt;&lt;br /&gt;$startTime = time(); &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #006080"&gt;&amp;quot;starting pattern match started &amp;lt;br \&amp;gt;&amp;quot;&lt;/span&gt;;       &lt;br /&gt;&lt;br /&gt; &lt;br /&gt;&lt;br /&gt;$secretString = &lt;span style="color: #006080"&gt;&amp;quot;daveda&amp;quot;&lt;/span&gt;; &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// loop1 &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; ($i = 97; $i &amp;lt; 123; $i ++)  &lt;br /&gt;&lt;br /&gt;{ &lt;br /&gt;&lt;br /&gt;        $iChar = chr($i);&lt;br /&gt;&lt;br /&gt;        &lt;span style="color: #008000"&gt;// loop2&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; ($j = 97; $j &amp;lt; 123; $j++)&lt;br /&gt;&lt;br /&gt;        {&lt;br /&gt;&lt;br /&gt;                $jChar = chr($j);&lt;br /&gt;&lt;br /&gt;                &lt;span style="color: #008000"&gt;// loop 3&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; ($k = 97; $k &amp;lt; 123; $k++)&lt;br /&gt;&lt;br /&gt;                {&lt;br /&gt;&lt;br /&gt;                        $kChar = chr($k);&lt;br /&gt;&lt;br /&gt;                        &lt;span style="color: #008000"&gt;// loop 4&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; ($l = 97; $l &amp;lt; 123; $l++)&lt;br /&gt;&lt;br /&gt;                        {&lt;br /&gt;&lt;br /&gt;                                $lChar = chr($l);&lt;br /&gt;&lt;br /&gt;                                &lt;span style="color: #008000"&gt;// loop 5&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; ($m = 97; $m &amp;lt; 123; $m++)&lt;br /&gt;&lt;br /&gt;                                {&lt;br /&gt;&lt;br /&gt;                                        $mChar = chr($m);&lt;br /&gt;&lt;br /&gt;                                        &lt;span style="color: #008000"&gt;// loop 6&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                        &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; ($n = 97; $n &amp;lt; 123; $n++)&lt;br /&gt;&lt;br /&gt;                                        {&lt;br /&gt;&lt;br /&gt;                                                $nChar = chr($n);&lt;br /&gt;&lt;br /&gt;                                                $tryString = $iChar . $jChar . $kChar . $lChar . $mChar . $nChar;&lt;br /&gt;&lt;br /&gt;                                                &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ($tryString == $secretString) {&lt;br /&gt;&lt;br /&gt;                                                        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #006080"&gt;&amp;quot;found secretString which is $tryString &amp;lt;br /&amp;gt;&amp;quot;&lt;/span&gt; ;&lt;br /&gt;&lt;br /&gt;                                                        $endTime = time();&lt;br /&gt;&lt;br /&gt;                                                        $totalTime = $endTime - $startTime;&lt;br /&gt;&lt;br /&gt;                                                        &lt;span style="color: #0000ff"&gt;echo&lt;/span&gt; &lt;span style="color: #006080"&gt;&amp;quot;Time taken in seconds is $totalTime &amp;lt;br /&amp;gt;&amp;quot;&lt;/span&gt;;&lt;br /&gt;&lt;br /&gt;                                                }&lt;span style="color: #008000"&gt;// end if&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                        } &lt;span style="color: #008000"&gt;// end loop 6&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                                } &lt;span style="color: #008000"&gt;// end loop 5       &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                        } &lt;span style="color: #008000"&gt;// end loop 4       &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                } &lt;span style="color: #008000"&gt;// end loop 3               &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        }&lt;span style="color: #008000"&gt;// end loop2&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;}&lt;span style="color: #008000"&gt;// end loop1 &lt;/span&gt;&lt;br /&gt;&lt;br /&gt; ?&amp;gt;  &lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;C (thanks to Dan)&lt;/h3&gt;

&lt;div&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;Compiled with GCC, and run under Cygwin.&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;stdio.h&amp;gt; &lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;time.h&amp;gt; &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; main() &lt;br /&gt;{ &lt;br /&gt;    &lt;span style="color: #0000ff"&gt;char&lt;/span&gt; * secretString  = &lt;span style="color: #006080"&gt;&amp;quot;davedave&amp;quot;&lt;/span&gt;;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;char&lt;/span&gt; tryString[10];&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;unsigned&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; counter = 0;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; i,j,k,l,m,n,o,p;&lt;br /&gt;    time_t start,end;&lt;br /&gt; &lt;br /&gt;    &lt;span style="color: #0000ff"&gt;double&lt;/span&gt; dif;&lt;br /&gt; &lt;br /&gt;    &lt;span style="color: #0000ff"&gt;unsigned&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; timeStart;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;unsigned&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; timeEnd;&lt;br /&gt; &lt;br /&gt;    time (&amp;amp;start);&lt;br /&gt; &lt;br /&gt;    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (i = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; i &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; i++)&lt;br /&gt;    {&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (j = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; j &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; j++)&lt;br /&gt;            {&lt;br /&gt;                    &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (k = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; k &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; k++)&lt;br /&gt;                    {&lt;br /&gt;                            &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (l = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; l &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; l++)&lt;br /&gt;                           {&lt;br /&gt;                                   &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(m = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; m &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; m++)&lt;br /&gt;                                   {&lt;br /&gt;                                           &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(n = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; n &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; n++)&lt;br /&gt;                                           {&lt;br /&gt;                                                   &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(o = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; o &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; o++)&lt;br /&gt;                                                   {&lt;br /&gt;                                                           &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(p = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; p &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; p++)&lt;br /&gt;                                                                   {&lt;br /&gt;                                                                   tryString[0] = (&lt;span style="color: #0000ff"&gt;char&lt;/span&gt;)i;&lt;br /&gt;                                                                   tryString[1] = (&lt;span style="color: #0000ff"&gt;char&lt;/span&gt;)j;&lt;br /&gt;                                                                   tryString[2] = (&lt;span style="color: #0000ff"&gt;char&lt;/span&gt;)k;&lt;br /&gt;                                                                   tryString[3] = (&lt;span style="color: #0000ff"&gt;char&lt;/span&gt;)l;&lt;br /&gt;                                                                   tryString[4] = (&lt;span style="color: #0000ff"&gt;char&lt;/span&gt;)m;&lt;br /&gt;                                                                   tryString[5] = (&lt;span style="color: #0000ff"&gt;char&lt;/span&gt;)n;&lt;br /&gt;                                                                   tryString[6] = (&lt;span style="color: #0000ff"&gt;char&lt;/span&gt;)o;&lt;br /&gt;                                                                   tryString[7] = (&lt;span style="color: #0000ff"&gt;char&lt;/span&gt;)p;&lt;br /&gt;                                                                   tryString[8] = &lt;span style="color: #006080"&gt;'\0'&lt;/span&gt;;&lt;br /&gt;&lt;br /&gt;                                                                   &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ( strcmp( secretString, tryString ) == 0 )&lt;br /&gt;                                                                   {&lt;br /&gt;                                                                           time (&amp;amp;end);&lt;br /&gt;                                                                           dif = difftime (end, start);&lt;br /&gt;                                                                           printf( &lt;span style="color: #006080"&gt;&amp;quot;\r\nSecretString is %s&amp;quot;&lt;/span&gt;, tryString );&lt;br /&gt;                                                                           printf( &lt;span style="color: #006080"&gt;&amp;quot;\r\nNumber combinations tried = %d&amp;quot;&lt;/span&gt;, counter );&lt;br /&gt;                                                                           printf (&lt;span style="color: #006080"&gt;&amp;quot;\r\nYou have taken %.2lf seconds to type your name.\n&amp;quot;&lt;/span&gt;, dif );&lt;br /&gt;                                                                           &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 1;&lt;br /&gt;                                                                   }&lt;br /&gt;                                                                   &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;&lt;br /&gt;                                                                   {&lt;br /&gt;                                                                           counter++;&lt;br /&gt;                                                                   }&lt;br /&gt;                                                           }&lt;br /&gt;                                                   }&lt;br /&gt;                                           }&lt;br /&gt;                                   }&lt;br /&gt;                           }&lt;br /&gt;                   }&lt;br /&gt;            }&lt;br /&gt;    }&lt;br /&gt;        printf(&lt;span style="color: #006080"&gt;&amp;quot;\r\nDid not find secret string %s after %d combinations&amp;quot;&lt;/span&gt;, secretString, counter );&lt;br /&gt;} &lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;h3&gt;C v1.1 (thanks to Darrin)&lt;/h3&gt;

&lt;p&gt;This may be the fastest so far?&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;stdio.h&amp;gt; &lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;time.h&amp;gt; &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; main() &lt;br /&gt;{ &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;char&lt;/span&gt; * secretString  = &lt;span style="color: #006080"&gt;&amp;quot;davedav&amp;quot;&lt;/span&gt;; &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;char&lt;/span&gt; tryString[10]; &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;unsigned&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; counter = 0; &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; i,j,k,l,m,n,o,p; &lt;br /&gt;   time_t start,end; &lt;br /&gt;     &lt;span style="color: #0000ff"&gt;double&lt;/span&gt; dif; &lt;br /&gt;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;unsigned&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; timeStart; &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;unsigned&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; timeEnd; &lt;br /&gt;     time (&amp;amp;start); &lt;br /&gt;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (i = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; i &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; i++) &lt;br /&gt;   { &lt;br /&gt;       tryString[0] = i; &lt;br /&gt;          &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (j = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; j &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; j++) &lt;br /&gt;       { &lt;br /&gt;           tryString[1] = j; &lt;br /&gt;           &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (k = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; k &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; k++) &lt;br /&gt;           { &lt;br /&gt;               tryString[2] = k; &lt;br /&gt;               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (l = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; l &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; l++) &lt;br /&gt;               { &lt;br /&gt;                   tryString[3] = l; &lt;br /&gt;                   &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(m = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; m &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; m++) &lt;br /&gt;                   { &lt;br /&gt;                       tryString[4] = m; &lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(n = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; n &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; n++) &lt;br /&gt;                       { &lt;br /&gt;                           tryString[5] = n; &lt;br /&gt;                           &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(o = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;; o &amp;lt;= &lt;span style="color: #006080"&gt;'z'&lt;/span&gt;; o++) &lt;br /&gt;                           { &lt;br /&gt;                               tryString[6] = o; &lt;br /&gt;                               &lt;span style="color: #008000"&gt;//for(p = 'a'; p &amp;lt;= 'z'; p++) &lt;/span&gt;&lt;br /&gt;                                   &lt;span style="color: #008000"&gt;//{ &lt;/span&gt;&lt;br /&gt;                                   &lt;span style="color: #008000"&gt;//tryString[7] = p; &lt;/span&gt;&lt;br /&gt;                                   tryString[7] = &lt;span style="color: #006080"&gt;'\0'&lt;/span&gt;; &lt;br /&gt;                                   &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ( strcmp( secretString, tryString ) == 0 ) &lt;br /&gt;                                   { &lt;br /&gt;                                       time (&amp;amp;end); &lt;br /&gt;                                       dif = difftime (end, start); &lt;br /&gt;                                       printf( &lt;span style="color: #006080"&gt;&amp;quot;\r\nSecretString is %s&amp;quot;&lt;/span&gt;, tryString ); &lt;br /&gt;                                       printf( &lt;span style="color: #006080"&gt;&amp;quot;\r\nNumber combinations tried = %d&amp;quot;&lt;/span&gt;, counter ); &lt;br /&gt;                                       printf (&lt;span style="color: #006080"&gt;&amp;quot;\r\nYou have taken %.2lf seconds to type your name.\n&amp;quot;&lt;/span&gt;, dif ); &lt;br /&gt;                                       &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 1; &lt;br /&gt;                                   } &lt;br /&gt;                                   &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; &lt;br /&gt;                                   { &lt;br /&gt;                                       counter++; &lt;br /&gt;                                   } &lt;br /&gt;                               &lt;span style="color: #008000"&gt;//} &lt;/span&gt;&lt;br /&gt;                           } &lt;br /&gt;                       } &lt;br /&gt;                   } &lt;br /&gt;               } &lt;br /&gt;           } &lt;br /&gt;       } &lt;br /&gt;         } &lt;br /&gt;     printf(&lt;span style="color: #006080"&gt;&amp;quot;\r\nDid not find secret string %s after %d combinations&amp;quot;&lt;/span&gt;, secretString, counter ); &lt;br /&gt;} &lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;div&gt;
  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;C v2 (thanks to Dan) uses pointers&lt;/h3&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;stdio.h&amp;gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;time.h&amp;gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// This is the maximum length of the string we are trying to guess&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#define&lt;/span&gt; MAX_SECRET_STRING_LENGTH 16&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt;&lt;br /&gt;main( &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; )&lt;br /&gt;{&lt;br /&gt; &lt;span style="color: #0000ff"&gt;char&lt;/span&gt;    tryString[MAX_SECRET_STRING_LENGTH];&lt;br /&gt; &lt;span style="color: #0000ff"&gt;char&lt;/span&gt;   *secretString = &lt;span style="color: #006080"&gt;&amp;quot;davedav&amp;quot;&lt;/span&gt;;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;unsigned&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;  numComparisons;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;    strLen;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;    i;&lt;br /&gt; time_t    start,end;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;unsigned&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;  timeStart;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;unsigned&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt;  timeEnd;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;double&lt;/span&gt;    dif;&lt;br /&gt;&lt;br /&gt;    time (&amp;amp;start);&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// Setting up start point of guesser&lt;/span&gt;&lt;br /&gt; strLen = 0;&lt;br /&gt; tryString[0] = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;;&lt;br /&gt; tryString[1] = &lt;span style="color: #006080"&gt;'\0'&lt;/span&gt;;&lt;br /&gt; numComparisons = 0;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; ( 1 )&lt;br /&gt; {&lt;br /&gt;  numComparisons++;&lt;br /&gt;&lt;span style="color: #008000"&gt;//  Check if this is the string we're after&lt;/span&gt;&lt;br /&gt;  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ( !strcmp( tryString, secretString ) )&lt;br /&gt;  {&lt;br /&gt;   time (&amp;amp;end);&lt;br /&gt;   dif = difftime (end, start);&lt;br /&gt;&lt;span style="color: #008000"&gt;//   We have found the string!&lt;/span&gt;&lt;br /&gt;   printf( &lt;span style="color: #006080"&gt;&amp;quot;Secret string is: %s\r\n&amp;quot;&lt;/span&gt;, tryString );&lt;br /&gt;   printf( &lt;span style="color: #006080"&gt;&amp;quot;Number of comprisons: %d\r&amp;quot;&lt;/span&gt;, numComparisons );&lt;br /&gt;   printf (&lt;span style="color: #006080"&gt;&amp;quot;\r\nCode took %.2lf seconds to run.\n&amp;quot;&lt;/span&gt;, dif );&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;return&lt;/span&gt;;&lt;br /&gt;  }&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;//  String doesn't match so increment the most right hand character&lt;/span&gt;&lt;br /&gt;  tryString[strLen]++;&lt;br /&gt;  &lt;br /&gt;&lt;span style="color: #008000"&gt;//  Is most right hand character z?&lt;/span&gt;&lt;br /&gt;  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ( tryString[strLen] == &lt;span style="color: #006080"&gt;'z'&lt;/span&gt; )&lt;br /&gt;  {&lt;br /&gt;&lt;span style="color: #008000"&gt;//   We need to roll one or more characters over to 'a'&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;//   Count i backwards from strLen to 0&lt;/span&gt;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; ( i = strLen; i &amp;gt;= 0; i-- )&lt;br /&gt;   {&lt;br /&gt;&lt;span style="color: #008000"&gt;//    Is the character at position i equal to z?  It always will be on &lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;//    the first loop&lt;/span&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ( tryString[i] == &lt;span style="color: #006080"&gt;'z'&lt;/span&gt; )&lt;br /&gt;    {&lt;br /&gt;&lt;span style="color: #008000"&gt;//     Have we reached position 0 ie the start of the string?&lt;/span&gt;&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; ( i == 0 )&lt;br /&gt;     {&lt;br /&gt;&lt;span style="color: #008000"&gt;//      We have just rolled over all the characters in our current try&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;//      string and have not yet found a match.  We must now try with&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;//      a string 1 character longer.&lt;/span&gt;&lt;br /&gt;      strLen++;&lt;br /&gt;      tryString[0] = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;;&lt;br /&gt;      tryString[strLen] = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;;&lt;br /&gt;&lt;span style="color: #008000"&gt;//      Delimit the string for the comparison&lt;/span&gt;&lt;br /&gt;      tryString[strLen + 1] = &lt;span style="color: #006080"&gt;'\0'&lt;/span&gt;;&lt;br /&gt;      &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;&lt;br /&gt;     }&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;&lt;br /&gt;     {&lt;br /&gt;&lt;span style="color: #008000"&gt;//     We haven't reached the beginning of string, so set current character&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;//     to a and previous character increment&lt;/span&gt;&lt;br /&gt;      tryString[i] = &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;;&lt;br /&gt;      tryString[i - 1]++;&lt;br /&gt;     }&lt;br /&gt;    }&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;else&lt;/span&gt;&lt;br /&gt;    {&lt;br /&gt;&lt;span style="color: #008000"&gt;//     If we are not incrementing this character then we won't be&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;//     incrementing any characters before it either.  So break out of the for i loop&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;//     and start incrementing the most right hand character again.&lt;/span&gt;&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;     &lt;br /&gt;    }&lt;br /&gt;   } &lt;span style="color: #008000"&gt;//for i...&lt;/span&gt;&lt;br /&gt;  } &lt;span style="color: #008000"&gt;//if&lt;/span&gt;&lt;br /&gt; } &lt;span style="color: #008000"&gt;//while&lt;/span&gt;&lt;br /&gt;}//main&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;C++ (thanks to Michael) Recursive Loop Simplified Version&lt;/h3&gt;

&lt;p&gt;Its performance is handicapped by its iterative deepening search method, oh well.&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #008000"&gt;// MikesRecursivePattern.cpp : main project file.&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &lt;span style="color: #006080"&gt;&amp;quot;stdafx.h&amp;quot;&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;iostream&amp;gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;string&amp;gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;time.h&amp;gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;using&lt;/span&gt; std::string;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// what length of string will it search for before it gives up...&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; MAX_SEARCH_LENGTH = 8;&lt;br /&gt;string secretString, guess;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; iterations = 0;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// checks to see it the string matches the secret string&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; CompareString() {&lt;br /&gt;   ++iterations;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; !guess.compare( secretString );&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// recursive function for scanning string&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; SearchString( string::iterator it )&lt;br /&gt;{&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; result = false;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( it != guess.end() ) {&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; letter = 97; letter &amp;lt; 123 &amp;amp;&amp;amp; !result; ++letter ) {&lt;br /&gt;           *it = (&lt;span style="color: #0000ff"&gt;char&lt;/span&gt;)letter;                          &lt;br /&gt;     &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( result = CompareString() ) &lt;br /&gt;      &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;&lt;br /&gt;           result = SearchString( it + 1 );  &lt;br /&gt;    }&lt;br /&gt;   }&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; result;&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; main()&lt;br /&gt;{&lt;br /&gt;   std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;Enter string to search for --&amp;gt;&amp;quot;&lt;/span&gt;;&lt;br /&gt;   std::getline( std::cin, secretString );&lt;br /&gt;   time_t    start,end;&lt;br /&gt;   time( &amp;amp;start );&lt;br /&gt;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; tryLength = 0; tryLength &amp;lt; MAX_SEARCH_LENGTH; ++tryLength ){&lt;br /&gt;       guess += &lt;span style="color: #006080"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( SearchString( guess.begin() ) )&lt;br /&gt;           &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;&lt;br /&gt;   }&lt;br /&gt;   time( &amp;amp;end );&lt;br /&gt;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( CompareString() ) {&lt;br /&gt;       std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;secret string: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; guess.c_str() &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;&lt;br /&gt;   } &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; {&lt;br /&gt;       std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;failed to find string. aaargh\n&amp;quot;&lt;/span&gt;;  &lt;br /&gt;   }&lt;br /&gt;&lt;br /&gt;   std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;iterations:    &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; iterations &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;&lt;br /&gt;   std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;time (secs):   &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; difftime (end, start) &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;;&lt;br /&gt;   &lt;span style="color: #008000"&gt;//stop the nasty app closing without showing results&lt;/span&gt;&lt;br /&gt;   std::getline( std::cin, secretString );&lt;br /&gt;  } &lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;C++ (thanks to Michael) Full Version&lt;/h3&gt;

&lt;p&gt;1) will find any length string you enter 
  &lt;br /&gt;2) the letters aren't hardcoded and can be changed but adding/subtracting to the letters string.&amp;#160; ( if you replace this with the searching section from the c code then it ought to be equally speedy ) 

  &lt;br /&gt;At the moment it is windows only, but that is only the timing code.&lt;/p&gt;

&lt;p&gt;&amp;#160;&lt;/p&gt;

&lt;div&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #cc6633"&gt;#ifdef&lt;/span&gt; _WIN32 &lt;br /&gt;   &lt;span style="color: #cc6633"&gt;#define&lt;/span&gt; WINVER                0x0500 &lt;br /&gt;   &lt;span style="color: #cc6633"&gt;#define&lt;/span&gt; _WIN32_WINNT    0x0500 &lt;br /&gt;   &lt;span style="color: #cc6633"&gt;#define&lt;/span&gt; _WIN32_IE            0x0501 &lt;br /&gt;&lt;br /&gt;   &lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;windows.h&amp;gt; &lt;br /&gt;&lt;span style="color: #cc6633"&gt;#endif&lt;/span&gt; &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;iostream&amp;gt; &lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;string&amp;gt; &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// what length of string will it search for before it gives up... &lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; MAX_SEARCH_LENGTH = 8; &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// define the letters to search for ie. possible secret string letters/symbols etc &lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; std::string letters = &lt;span style="color: #006080"&gt;&amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;&lt;/span&gt;; &lt;br /&gt;&lt;span style="color: #008000"&gt;// the letters string doesn't change &lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;const&lt;/span&gt; std::string::const_iterator itLettersEnd = letters.end(); &lt;br /&gt;&lt;br /&gt;std::string secretString; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// counter &lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; iterations = 0; &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// checks to see it the string matches the secret string &lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; CompareString( &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; std::string&amp;amp; test ) { &lt;br /&gt;   ++iterations; &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; test.compare( secretString ) == 0; &lt;br /&gt;} &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// performs the search &lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;class&lt;/span&gt; Search { &lt;br /&gt;   std::string test_; &lt;br /&gt;     &lt;span style="color: #008000"&gt;// recursive function that searches the string &lt;/span&gt;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; SearchString( std::string::iterator it ) { &lt;br /&gt;       &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; result = false; &lt;br /&gt;       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( it != test_.end() ) { &lt;br /&gt;           &lt;span style="color: #008000"&gt;// search all possible letters &lt;/span&gt;&lt;br /&gt;           &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;( std::string::const_iterator itLetter = letters.begin(); itLetter != itLettersEnd &amp;amp;&amp;amp; !result; ++itLetter ) { &lt;br /&gt;               *it = *itLetter;                              &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( CompareString( test_ ) ) { &lt;br /&gt;                   result = true; &lt;br /&gt;                   &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;; &lt;br /&gt;               } &lt;br /&gt;               &lt;span style="color: #008000"&gt;// move to the next letter and call this function &lt;/span&gt;&lt;br /&gt;               result = SearchString( it + 1 );                          }                  }              &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; result; &lt;br /&gt;   } &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt;: &lt;br /&gt;   &lt;span style="color: #008000"&gt;// constructor requires length of string to search &lt;/span&gt;&lt;br /&gt;   Search( &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; length ) : test_( length, &lt;span style="color: #006080"&gt;'a'&lt;/span&gt;)  {} &lt;br /&gt;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; &lt;span style="color: #0000ff"&gt;char&lt;/span&gt;* GetString() &lt;span style="color: #0000ff"&gt;const&lt;/span&gt; { &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; test_.c_str(); } &lt;br /&gt;     &lt;span style="color: #008000"&gt;// call this to start the recursive search &lt;/span&gt;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;bool&lt;/span&gt; SearchString() { &lt;br /&gt;       &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; SearchString( test_.begin() ); &lt;br /&gt;   } &lt;br /&gt;  }; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; main() &lt;br /&gt;{ &lt;br /&gt;   std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;Enter string to search for --&amp;gt;&amp;quot;&lt;/span&gt;; &lt;br /&gt;   std::getline( std::cin, secretString ); &lt;br /&gt;   std::string result = &lt;span style="color: #006080"&gt;&amp;quot;&amp;quot;&lt;/span&gt;; &lt;br /&gt;     LARGE_INTEGER start; &lt;br /&gt;   QueryPerformanceCounter( &amp;amp;start ); &lt;br /&gt;&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; tryLength = 0; tryLength &amp;lt; MAX_SEARCH_LENGTH; ++tryLength ){ &lt;br /&gt;       Search tryString(tryLength + 1); &lt;br /&gt;       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( tryString.SearchString() ) { &lt;br /&gt;           result = tryString.GetString(); &lt;br /&gt;           &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;; &lt;br /&gt;       } &lt;br /&gt;   } &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;   LARGE_INTEGER finish; &lt;br /&gt;   QueryPerformanceCounter( &amp;amp;finish ); &lt;br /&gt;   LARGE_INTEGER freq; &lt;br /&gt;   QueryPerformanceFrequency( &amp;amp;freq ); &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;double&lt;/span&gt; totalTime = (&lt;span style="color: #0000ff"&gt;double&lt;/span&gt;)(finish.QuadPart - start.QuadPart) / freq.QuadPart; &lt;br /&gt;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;if&lt;/span&gt;( !result.empty() ) { &lt;br /&gt;       std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;secret string: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; result.c_str() &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;; &lt;br /&gt;   } &lt;span style="color: #0000ff"&gt;else&lt;/span&gt; { &lt;br /&gt;       std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;failed to find string, aaargh\n&amp;quot;&lt;/span&gt;;          } &lt;br /&gt;     std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;iterations:    &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; iterations &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;; &lt;br /&gt;   std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;time (secs):   &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; totalTime &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;; &lt;br /&gt;     &lt;span style="color: #008000"&gt;//stop the nasty app closing immediately &lt;/span&gt;&lt;br /&gt;   std::getline( std::cin, secretString ); &lt;br /&gt;}&lt;/pre&gt;
&lt;/div&gt;

&lt;div&gt;&amp;#160;&lt;/div&gt;

&lt;h3&gt;C++ Mininal Crazy Version (thanks to Michael)&lt;/h3&gt;

&lt;p&gt;I sacrificed speed somewhat for the sake of making it difficult to understand. 
  &lt;br /&gt;All the other programs on your site seemed to be taking it seriously! (it is only partially 

  &lt;br /&gt;obfuscated currently... just wait 'till I'm finished&amp;#160; ) As you will be able to tell it uses a 

  &lt;br /&gt;somewhat different approach from the other programs, although it still is a simple loop. 

  &lt;br /&gt;Anyway on my machine it runs about 80 seconds for 7 letters. This is handicapped by 

  &lt;br /&gt;searching the wrong direction: In reverse; vadevad takes only 10 secs.&lt;/p&gt;

&lt;p&gt;
  &lt;br /&gt;davedave: -&amp;gt; 610 seconds 

  &lt;br /&gt;evadevad: -&amp;gt; 396 seconds&lt;/p&gt;

&lt;p&gt;
  &lt;br /&gt;Maybe you need a palindrome? ( or maybe i should just reverse my algorithm ;-)&amp;#160;&amp;#160; ) 

  &lt;br /&gt;Anyway my code is pretty short (the algorithm is 6 lines) so here goes...&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;iostream&amp;gt; &lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;string&amp;gt; &lt;br /&gt;&lt;span style="color: #cc6633"&gt;#include&lt;/span&gt; &amp;lt;time.h&amp;gt; &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;typedef&lt;/span&gt; &lt;span style="color: #0000ff"&gt;unsigned&lt;/span&gt; __int64 E; &lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; main() &lt;br /&gt;{ &lt;br /&gt;   std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;Enter string to search for (12 letters max)...\n&amp;gt;&amp;gt; &amp;quot;&lt;/span&gt;; &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;char&lt;/span&gt; c, s[12];    std::cin &amp;gt;&amp;gt; s; &lt;br /&gt;     time_t b,f; &lt;br /&gt;   time( &amp;amp;b); &lt;br /&gt;&lt;br /&gt;   E y=0,e=0;      &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; p, l = strlen( s );      &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(p=0;p&amp;lt;l;e|=(E)p[s]-97&amp;lt;&amp;lt;p++*5); &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(;y!=e;++y);           std::string O = &lt;span style="color: #006080"&gt;&amp;quot;&amp;quot;&lt;/span&gt;; &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;for&lt;/span&gt;(p=0;p&amp;lt;l;O+=97+((e&amp;gt;&amp;gt;p++*5)&amp;amp;31)); &lt;br /&gt;     time( &amp;amp;f); &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;double&lt;/span&gt; t = difftime( f, b ); &lt;br /&gt;     std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;secret string: &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; O.c_str() &amp;lt;&amp;lt; std::endl; &lt;br /&gt;   std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;iterations:    &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl; &lt;br /&gt;   std::cout &amp;lt;&amp;lt; &lt;span style="color: #006080"&gt;&amp;quot;time (secs):   &amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; std::endl;   } &lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;p&gt;Whew! There it goes This ought to work several compilers (with an appropriate substitution for the __int64 typedef for non-microsoft ones )&lt;/p&gt;

&lt;p&gt;Also if you happen to have a 64bit machine lying I'm confident you could give this program a significant performance boost, since everything is, well, 64bit numbers.&lt;/p&gt;

&lt;div&gt;
  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;Java (thanks to Phil)&lt;/h3&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.*;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; RunMe {&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; main(String[] args) {&lt;br /&gt;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; l1,l2,l3,l4,l5,l6,loop;&lt;br /&gt;       String a1,a2,a3,a4,a5,a6;&lt;br /&gt;       String secret,testword;&lt;br /&gt;       Date date;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;long&lt;/span&gt; start,finish;&lt;br /&gt;       date = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Date();&lt;br /&gt;       start = date.getTime();&lt;br /&gt;       secret = &lt;span style="color: #006080"&gt;&amp;quot;daveda&amp;quot;&lt;/span&gt;;&lt;br /&gt;       loop=0;&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (l1=97;l1&amp;lt;=122;l1++){&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (l2=97;l2&amp;lt;=122;l2++){&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (l3=97;l3&amp;lt;=122;l3++){&lt;br /&gt;                               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (l4=97;l4&amp;lt;=122;l4++){&lt;br /&gt;                                       &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (l5=97;l5&amp;lt;=122;l5++){&lt;br /&gt;                                               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (l6=97;l6&amp;lt;=122;l6++){&lt;br /&gt;                                               &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[] bytes = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; &lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;[1];&lt;br /&gt;                       bytes[0] = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;) l1;&lt;br /&gt;                       a1 = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; String(bytes);&lt;br /&gt;                       bytes[0] = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;) l2;&lt;br /&gt;                       a2 = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; String(bytes);&lt;br /&gt;                       bytes[0] = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;) l3;&lt;br /&gt;                       a3 = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; String(bytes);&lt;br /&gt;                       bytes[0] = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;) l4;&lt;br /&gt;                       a4 = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; String(bytes);&lt;br /&gt;                       bytes[0] = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;) l5;&lt;br /&gt;                       a5 = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; String(bytes);&lt;br /&gt;                       bytes[0] = (&lt;span style="color: #0000ff"&gt;byte&lt;/span&gt;) l6;&lt;br /&gt;                       a6 = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; String(bytes);&lt;br /&gt;&lt;br /&gt;                                               testword = a1 + a2 + a3 + a4 +a5 +a6;&lt;br /&gt;&lt;br /&gt;                                               loop = loop + 1;&lt;br /&gt;                                               &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (testword.equals(secret)){&lt;br /&gt;                                                       date = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Date();&lt;br /&gt;                                                       finish = date.getTime();&lt;br /&gt;                                                       System.out.println(&lt;span style="color: #006080"&gt;&amp;quot;Task completed in: (milliseconds) (loops):&amp;quot;&lt;/span&gt;);&lt;br /&gt;                                                       System.out.println(finish-start);&lt;br /&gt;                                                       System.out.println (Integer.toString(loop));&lt;br /&gt;                                                       }&lt;br /&gt;                                               }&lt;span style="color: #008000"&gt;//loop 6&lt;/span&gt;&lt;br /&gt;                                       }&lt;span style="color: #008000"&gt;//loop 5&lt;/span&gt;&lt;br /&gt;                               }&lt;span style="color: #008000"&gt;//loop 4&lt;/span&gt;&lt;br /&gt;                       }&lt;span style="color: #008000"&gt;//loop 3&lt;/span&gt;&lt;br /&gt;               }&lt;span style="color: #008000"&gt;//loop 2&lt;/span&gt;&lt;br /&gt;       }&lt;span style="color: #008000"&gt;//loop 1&lt;/span&gt;&lt;br /&gt; }&lt;span style="color: #008000"&gt;//end of method&lt;/span&gt;&lt;br /&gt;} //end of class&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;Java Object Based Approach (thanks Phil)&lt;/h3&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; Counter {&lt;br /&gt; &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; String list; &lt;br /&gt; &lt;span style="color: #0000ff"&gt;private&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; x;&lt;br /&gt;  &lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; Counter(){&lt;br /&gt; x=0;&lt;br /&gt; list = &lt;span style="color: #006080"&gt;&amp;quot;abcdefghijklmnopqrstuvwxyz&amp;quot;&lt;/span&gt;; &lt;br /&gt; }&lt;br /&gt; &lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; add(){&lt;br /&gt;  x=x+1;&lt;br /&gt;  &lt;br /&gt;  &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (x ==26) {&lt;br /&gt;   x=0;&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 1;  &lt;span style="color: #008000"&gt;//signifies a reset has occurred&lt;/span&gt;&lt;br /&gt;   }  &lt;br /&gt;  &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 0;&lt;br /&gt;  &lt;br /&gt; }&lt;br /&gt; &lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; String status(){&lt;br /&gt;  &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; list.substring(x,x+1);&lt;br /&gt; }  &lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; length(){&lt;br /&gt;  &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; list.length ();&lt;br /&gt; }&lt;br /&gt; &lt;br /&gt;}&lt;span style="color: #008000"&gt;// end of class&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;------------------------------------------&lt;br /&gt;&lt;span style="color: #008000"&gt;//OBJECT:Container.Java&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.*;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; Container {&lt;br /&gt; Vector v;&lt;br /&gt; &lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; Container(){&lt;br /&gt; v = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Vector();&lt;br /&gt; }&lt;br /&gt; &lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; addElement(Counter c){&lt;br /&gt;&lt;br /&gt;  &lt;span style="color: #008000"&gt;//copy label ref to object... not actual copy of object!!&lt;/span&gt;&lt;br /&gt;    &lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.v.addElement(c);&lt;br /&gt;  }&lt;br /&gt;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; String reportAll(){&lt;br /&gt;  &lt;br /&gt; String out,working;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; t;&lt;br /&gt; Enumeration e;&lt;br /&gt; e=&lt;span style="color: #0000ff"&gt;this&lt;/span&gt;.v.elements();&lt;br /&gt; Counter c;&lt;br /&gt;   &lt;br /&gt; out = &lt;span style="color: #006080"&gt;&amp;quot;&amp;quot;&lt;/span&gt;;&lt;br /&gt;&lt;br /&gt; &lt;span style="color: #008000"&gt;//run thru all points and return as a single string&lt;/span&gt;&lt;br /&gt;  &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; (e.hasMoreElements()){&lt;br /&gt;  c=(Counter) e.nextElement();&lt;br /&gt;  out=out+(c.status());   &lt;br /&gt;  }&lt;br /&gt;  &lt;br /&gt; &lt;span style="color: #008000"&gt;//switch order - reverse&lt;/span&gt;&lt;br /&gt; working = out;&lt;br /&gt; out=&lt;span style="color: #006080"&gt;&amp;quot;&amp;quot;&lt;/span&gt;;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; (t=working.length();t&amp;gt;0;t--){&lt;br /&gt;  out = out+ working.substring(t-1,t);&lt;br /&gt; }&lt;br /&gt; &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; out;&lt;br /&gt; } &lt;br /&gt; &lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; returnLength(){&lt;br /&gt; &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; v.size();&lt;br /&gt; }&lt;br /&gt; &lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; String returnLetter(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; pos){&lt;br /&gt;  String l;&lt;br /&gt;  Counter lc;&lt;br /&gt;  &lt;br /&gt;  lc=(Counter) v.elementAt(pos);&lt;br /&gt;  l = lc.status();&lt;br /&gt;  &lt;br /&gt;  &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; l;&lt;br /&gt;  &lt;br /&gt; }&lt;br /&gt; &lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; addOne(&lt;span style="color: #0000ff"&gt;int&lt;/span&gt; pos){&lt;br /&gt; Counter t;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; temp;&lt;br /&gt; t = (Counter) v.elementAt (pos);&lt;br /&gt; temp = t.add();&lt;br /&gt; &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (temp==1){&lt;br /&gt;  &lt;span style="color: #008000"&gt;//counter reset need to add one to element left of current&lt;/span&gt;&lt;br /&gt;  &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 1;&lt;br /&gt; }&lt;br /&gt; &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; 0;&lt;br /&gt; }&lt;br /&gt; &lt;br /&gt; }&lt;span style="color: #008000"&gt;//end class&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;------------------------------------------&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;//MyDriver.Java&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;import&lt;/span&gt; java.util.Date;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// Java - Object based Brute Force PassWord Cracker&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #008000"&gt;// Author - Phil Bartie -  1 Jan 2006&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;class&lt;/span&gt; MyDriver {&lt;br /&gt;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;public&lt;/span&gt; &lt;span style="color: #0000ff"&gt;static&lt;/span&gt; &lt;span style="color: #0000ff"&gt;void&lt;/span&gt; main(String[] args) {&lt;br /&gt; String secret;&lt;br /&gt; Counter c; &lt;br /&gt; Container ct;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;int&lt;/span&gt; temp,t;&lt;br /&gt; &lt;span style="color: #0000ff"&gt;long&lt;/span&gt; loop,start,finish;&lt;br /&gt; Date date;&lt;br /&gt; date = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Date();&lt;br /&gt; start = date.getTime();&lt;br /&gt; ct = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Container();&lt;br /&gt; loop=0;&lt;br /&gt; secret = &lt;span style="color: #006080"&gt;&amp;quot;daveda&amp;quot;&lt;/span&gt;;&lt;br /&gt; &lt;br /&gt; &lt;span style="color: #008000"&gt;//add basic unit&lt;/span&gt;&lt;br /&gt; ct.addElement(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Counter());&lt;br /&gt; &lt;br /&gt; &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; (ct.reportAll().compareTo(secret) !=0){&lt;br /&gt;  loop++;&lt;br /&gt;  &lt;span style="color: #008000"&gt;//System.out.println(ct.reportAll());&lt;/span&gt;&lt;br /&gt;  &lt;br /&gt;   temp = ct.returnLength(); &lt;span style="color: #008000"&gt;// static value of length of vector&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;   t=0;&lt;br /&gt;   &lt;br /&gt;   &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; (ct.addOne(t)==1){&lt;br /&gt;    t++;&lt;br /&gt;    &lt;br /&gt;    &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; (temp==t){   &lt;span style="color: #008000"&gt;//character reached 'z' so need new counter object&lt;/span&gt;&lt;br /&gt;     ct.addElement(&lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Counter());&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;break&lt;/span&gt;;&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;   }&lt;br /&gt;   }&lt;span style="color: #008000"&gt;//end for loop&lt;/span&gt;&lt;br /&gt;&lt;br /&gt; &lt;span style="color: #008000"&gt;//report result and number of iterations required&lt;/span&gt;&lt;br /&gt; System.out.println(&lt;span style="color: #006080"&gt;&amp;quot;MATCH for:&amp;quot;&lt;/span&gt;+ ct.reportAll()+&lt;span style="color: #006080"&gt;&amp;quot; @ loop &amp;quot;&lt;/span&gt; + loop);&lt;br /&gt; date = &lt;span style="color: #0000ff"&gt;new&lt;/span&gt; Date();&lt;br /&gt; finish = date.getTime();&lt;br /&gt; System.out.println (&lt;span style="color: #006080"&gt;&amp;quot;Task completed in: &amp;quot;&lt;/span&gt; + (finish-start)+&lt;span style="color: #006080"&gt;&amp;quot; (milliseconds)&amp;quot;&lt;/span&gt;);&lt;br /&gt;&lt;br /&gt; }&lt;span style="color: #008000"&gt;//end main method&lt;/span&gt;&lt;br /&gt;}//end class&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;Python (Phil)&lt;/h3&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;import time&lt;br /&gt;&lt;br /&gt;# setup &lt;span style="color: #0000ff"&gt;string&lt;/span&gt; to find by brute force&lt;br /&gt;loopcounter =0&lt;br /&gt;secret = &lt;span style="color: #006080"&gt;&amp;quot;daveda&amp;quot;&lt;/span&gt;&lt;br /&gt;starttime = time.strftime(&lt;span style="color: #006080"&gt;'%X'&lt;/span&gt;)&lt;br /&gt;&lt;br /&gt;print starttime&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;for&lt;/span&gt; l1 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range(97,122):&lt;br /&gt;   &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; l2 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range (97,122):&lt;br /&gt;       &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; l3 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range (97,122):&lt;br /&gt;           &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; l4 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range (97,122):&lt;br /&gt;               &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; l5 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range (97,122):&lt;br /&gt;                   &lt;span style="color: #0000ff"&gt;for&lt;/span&gt; l6 &lt;span style="color: #0000ff"&gt;in&lt;/span&gt; range(97,122):&lt;br /&gt;                       loopcounter=loopcounter+1&lt;br /&gt;                       testword=chr(l1) + chr(l2) + chr(l3) + chr(l4)+chr(l5)+chr(l6)&lt;br /&gt;                       &lt;span style="color: #0000ff"&gt;if&lt;/span&gt; testword == secret:&lt;br /&gt;                           print time.strftime(&lt;span style="color: #006080"&gt;'%X'&lt;/span&gt;)&lt;br /&gt;                           print testword + &lt;span style="color: #006080"&gt;&amp;quot; found after&amp;quot;&lt;/span&gt;+str(loopcounter) +&lt;span style="color: #006080"&gt;&amp;quot; iterations&amp;quot;&lt;/span&gt;&lt;br /&gt;                           #terminate command needed here&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;Python (thanks Phil) Base 26 version&lt;/h3&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;import string,time&lt;br /&gt;alp = &lt;span style="color: #006080"&gt;'abcdefghijklmnopqrstuvwxyz'&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;def ntb(num, base):&lt;br /&gt;     stack = []&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;while&lt;/span&gt; num:&lt;br /&gt;         stack.append(alp[num % base])&lt;br /&gt;         num = num / base&lt;br /&gt;     stack.reverse()&lt;br /&gt;     &lt;span style="color: #0000ff"&gt;return&lt;/span&gt; &lt;span style="color: #006080"&gt;&amp;quot;&amp;quot;&lt;/span&gt;.join(stack)&lt;br /&gt;    &lt;br /&gt;testword=&lt;span style="color: #006080"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;br /&gt;secretword = &lt;span style="color: #006080"&gt;&amp;quot;daved&amp;quot;&lt;/span&gt;&lt;br /&gt;counter = 1L  #&lt;span style="color: #0000ff"&gt;long&lt;/span&gt;&lt;br /&gt;starttime = time.clock()&lt;br /&gt;print &lt;span style="color: #006080"&gt;&amp;quot;Running...&amp;quot;&lt;/span&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;while&lt;/span&gt; (testword&amp;lt;&amp;gt;secretword):&lt;br /&gt;    testword=ntb(counter,26)&lt;br /&gt;    counter = counter+1&lt;br /&gt;endtime = time.clock()&lt;br /&gt;print &lt;span style="color: #006080"&gt;&amp;quot;Secret word: &amp;quot;&lt;/span&gt; + testword + &lt;span style="color: #006080"&gt;&amp;quot; found after &amp;quot;&lt;/span&gt; + str(counter) +&lt;span style="color: #006080"&gt;&amp;quot; attempts&amp;quot;&lt;/span&gt;&lt;br /&gt;print &lt;span style="color: #006080"&gt;&amp;quot;Search took: &amp;quot;&lt;/span&gt; + str(round(endtime-starttime,3)) + &lt;span style="color: #006080"&gt;&amp;quot; seconds&amp;quot;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;

&lt;h3&gt;VB.NET&lt;/h3&gt;

&lt;p&gt;Not sure if this compiles&lt;/p&gt;

&lt;div id="codeSnippetWrapper"&gt;
  &lt;pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; border-right-style: none; background-color: #f4f4f4; margin: 0em; padding-left: 0px; width: 100%; padding-right: 0px; font-family: &amp;#39;Courier New&amp;#39;, courier, monospace; direction: ltr; border-top-style: none; color: black; font-size: 8pt; border-left-style: none; overflow: visible; padding-top: 0px" id="codeSnippet"&gt;&lt;span style="color: #0000ff"&gt;Dim&lt;/span&gt; secretString &lt;span style="color: #0000ff"&gt;As&lt;/span&gt; &lt;span style="color: #0000ff"&gt;String&lt;/span&gt; = &lt;span style="color: #006080"&gt;&amp;quot;da&amp;quot;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;Dim&lt;/span&gt; tryString&lt;br /&gt;&lt;br /&gt;       MessageBox.Show(&lt;span style="color: #006080"&gt;&amp;quot;Starting crypto search.&amp;quot;&lt;/span&gt;)&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;Dim&lt;/span&gt; i &lt;span style="color: #0000ff"&gt;As&lt;/span&gt; &lt;span style="color: #0000ff"&gt;Integer&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;For&lt;/span&gt; i = 97 &lt;span style="color: #0000ff"&gt;To&lt;/span&gt; 122&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;Dim&lt;/span&gt; j &lt;span style="color: #0000ff"&gt;As&lt;/span&gt; &lt;span style="color: #0000ff"&gt;Integer&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;For&lt;/span&gt; j = 97 &lt;span style="color: #0000ff"&gt;To&lt;/span&gt; 122&lt;br /&gt;&lt;br /&gt;               tryString = Chr(i) + Chr(j)&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;If&lt;/span&gt; tryString = secretString &lt;span style="color: #0000ff"&gt;Then&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;                   MessageBox.Show(&lt;span style="color: #006080"&gt;&amp;quot;Found secretString which is &amp;quot;&lt;/span&gt; &amp;amp; tryString)&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;End&lt;/span&gt; &lt;span style="color: #0000ff"&gt;If&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;Next&lt;/span&gt; &lt;span style="color: #008000"&gt;' Next j loop&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span style="color: #0000ff"&gt;Next&lt;/span&gt; &lt;span style="color: #008000"&gt;' Next i loop&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;       MessageBox.Show(&lt;span style="color: #006080"&gt;&amp;quot;End crypto and last tryString is &amp;quot;&lt;/span&gt; &amp;amp; tryString)&lt;/pre&gt;

  &lt;br /&gt;&lt;/div&gt;</Content>
      <Created>2010-10-12T18:24:23.1689631-04:00</Created>
      <Modified>2010-10-15T19:47:28.700875-04:00</Modified>
      <EntryId>517321c0-180d-41d6-9862-ac26feac58cf</EntryId>
      <Description />
      <Title>Code Guessing Program</Title>
      <Categories>Coding Challenge;Password Cracker</Categories>
      <Author>admin</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
    <Entry>
      <Content>&lt;p&gt;&lt;a href="http://should.codeplex.com/"&gt;http://should.codeplex.com/&lt;/a&gt;&lt;/p&gt;  &lt;p&gt;&lt;a href="http://www.programgood.net/content/binary/WindowsLiveWriter/ShouldAssertionLibrary_C006/image_2.png"&gt;&lt;img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="image" border="0" alt="image" src="http://www.programgood.net/content/binary/WindowsLiveWriter/ShouldAssertionLibrary_C006/image_thumb.png" width="640" height="484" /&gt;&lt;/a&gt; &lt;/p&gt;  &lt;p&gt;It is open source.&amp;#160; This is somewhat of a reminder to myself to go and check out the code too.&lt;/p&gt;</Content>
      <Created>2010-10-11T20:40:08.9335-04:00</Created>
      <Modified>2010-10-11T20:40:08.9335-04:00</Modified>
      <EntryId>14a94cd8-12ff-4e15-9fde-e7adb18e634c</EntryId>
      <Description />
      <Title>Should Assertion Library</Title>
      <Categories>BDD;Testing</Categories>
      <Author>admin</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
  </Entries>
</DayEntry>